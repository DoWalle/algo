

```python
class Solution:
    def solution(self, n, red_edges, blue_edges):

        if n == 0: return -1
        if n == 1: return [0]

        answer = [float("inf") for _ in range(n)]
        red_graph = [[] for _ in range(n)]
        blue_graph = [[] for _ in range(n)]
        for node_1, node_2 in red_edges:
            red_graph[node_1].append(node_2)
        for node_1, node_2 in blue_edges:
            blue_graph[node_1].append(node_2)
        
        red, blue = 1, -1

        # node (节点编号，走到此节点的颜色(初始节点特殊处理)，走到此节点用的最短步数)
        queue = [(0, 1, 0),(0, -1, 0)]
        visited = [(0, 1),(0, -1)]                      # 以一种颜色走到这个点，不必再走了
        num = 0

        while queue:

            node, color, step = queue.pop(0)
            answer[node] = min(answer[node], step)      # 保存经过这个点时最短的步
            if color==red:                              # 如果当前走的路是红色
                for next_node in blue_graph[node]:          # 下一步从蓝色里面找
                    if (next_node, blue) not in visited:    # 以蓝色的路走到这个点没走过
                        queue.append((next_node, blue, step+1))
                        visited.append((next_node, blue))
            if color==blue:
                for next_node in red_graph[node]:
                    if (next_node, red) not in visited:
                        queue.append((next_node, red, step+1))
                        visited.append((next_node, red))

        for i in range(n):
            if answer[i] == float("inf"):
                answer[i] = -1
```
        return answer
class Solution:

    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:

        red_path = [set() for i in range(n)]

        blue_path = [set() for i in range(n)]

        dist = [[None, None] for i in range(n)]

        dist[0] = [0, 0]

        step = 0

        now_red = [0]

        now_blue = [0]

        for start, end in red_edges:

            red_path[start].add(end)

        for start, end in blue_edges:

            blue_path[start].add(end)

        # step 1 找到分别以红边开始和以蓝边开始的两条最短路径

        while len(now_red) != 0 or len(now_blue) != 0 :

            new_red, new_blue = [], []

            step += 1

            if len(now_blue) != 0:

                for point in now_blue:

                    for next_point in red_path[point]:

                        if dist[next_point][0] is None:

                            new_red.append(next_point)

                            dist[next_point][0] = step

            if len(now_red) != 0:

                for point in now_red:

                    for next_point in blue_path[point]:

                        if dist[next_point][1] is None:

                            new_blue.append(next_point)

                            dist[next_point][1] = step

            now_red, now_blue = new_red, new_blue

        # step 2 在这两条最短路径中选择小的，merge成我们的答案

        ans = []

        for i in range(n):

            if dist[i][0] is None and dist[i][1] is None:

                ans.append(-1)

            elif dist[i][0] is not None and dist[i][1] is not None:

                ans.append(min(dist[i][0], dist[i][1]))

            elif dist[i][0] is not None:

                ans.append(dist[i][0])

            else:

                ans.append(dist[i][1])

        return ans

