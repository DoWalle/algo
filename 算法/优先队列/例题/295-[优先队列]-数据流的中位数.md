#### [295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)

[题解:](https://leetcode-cn.com/problems/find-median-from-data-stream/solution/gong-shui-san-xie-jing-dian-shu-ju-jie-g-pqy8/)

这是一道经典的数据结构运用题。

具体的，我们可以使用两个优先队列（堆）来维护整个数据流数据，令维护数据流左半边数据的优先队列（堆）为 l，维护数据流右半边数据的优先队列（堆）为 r。

显然，为了可以在 O(1) 的复杂度内取得当前中位数，我们应当令 l 为大根堆，r 为小根堆，并人为固定 l 和 r 之前存在如下的大小关系：

1. 当数据流元素数量为偶数：l 和 r 大小相同，此时动态中位数为两者堆顶元素的平均值；
2. 当数据流元素数量为奇数：l 比 r 多一，此时动态中位数为 l 的堆顶原数。

时间复杂度：addNum 函数的复杂度为 O(logn)；findMedian 函数的复杂度为 O(1)

空间复杂度：O(n)

```python
class MedianFinder:

    def __init__(self):
        self.smallQue = []  # 小的一半大根堆
        self.bigQue = []    # 大的一半，小根堆

    def addNum(self, num: int) -> None:
        if not self.smallQue or num < -self.smallQue[0]:
            heapq.heappush(self.smallQue, -num) # 负的放进去，小的变大的
            if len(self.smallQue) > len(self.bigQue) + 1:
                # 把小一半中的最大的放到大的一半中
                heapq.heappush(self.bigQue, -heapq.heappop(self.smallQue))
        elif num >= -self.smallQue[0]:
            heapq.heappush(self.bigQue, num)
            if len(self.bigQue) > len(self.smallQue):
                heapq.heappush(self.smallQue, -heapq.heappop(self.bigQue))

    def findMedian(self) -> float:
        if len(self.smallQue) > len(self.bigQue):
            return -self.smallQue[0]
        return (-self.smallQue[0] + self.bigQue[0]) / 2
```

**模板写法**

```python
import heapq
class Heap:
    
    def __init__(self, name="small"):
        self.arr = []
        self.transform = lambda x: x if name=="small" else -x

    def push(self, num):
        # 推入一个
        heapq.heappush(self.arr, self.transform(num))

    def pop(self):
        # 弹出堆顶
        return self.transform(heapq.heappop(self.arr))

    @property
    def top(self):
        # 获取堆顶元素
        return self.transform(self.arr[0])
    
    @property
    def length(self):
        return len(self.arr)
    
    @property
    def isEmpty(self):
        return len(self.arr) == 0
    

class MedianFinder:

    def __init__(self):
        self.small = Heap("big")  # 小的一半大根堆
        self.big = Heap("small")    # 大的一半，小根堆

    def addNum(self, num: int) -> None:
        if self.small.isEmpty or num < self.small.top:
            self.small.push(num)
            if self.small.length > self.big.length + 1:
                # 把小一半中的最大的放到大的一半中
                self.big.push(self.small.pop())
        elif num >= self.small.top:
            self.big.push(num)
            if self.big.length > self.small.length:
                self.small.push(self.big.pop())

    def findMedian(self) -> float:
        if self.small.length > self.big.length:
            return self.small.top
        return (self.small.top + self.big.top) / 2


# Your MedianFinder object will be instantiated and called as such:
# obj = MedianFinder()
# obj.addNum(num)
# param_2 = obj.findMedian()
```
