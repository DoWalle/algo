#### [721. 账户合并](https://leetcode-cn.com/problems/accounts-merge/)

[**方法一：并查集**](https://leetcode-cn.com/problems/accounts-merge/solution/tu-jie-yi-ran-shi-bing-cha-ji-by-yexiso-5ncf/)

```python
class UnionFind:
    def __init__(self):
        """
        记录每个节点的父节点
        """
        self.father = {}    
    
    def add(self, x):
        """
        添加新节点
        当把一个新节点添加到并查集中，它的父节点应该为空
        """
        if x not in self.father:
            self.father[x] = None

    def find(self, x):
        """
        查找根节点，如果节点的父节点不为空，那就不断迭代。
        """
        root = x

        while self.father[root] != None:
            root = self.father[root]

        # 路径压缩
        while x != root:
            original_father = self.father[x]
            self.father[x] = root
            x = original_father

        return root

    def merge(self, x, y):
        """
        合并两个节点，y的根结点作为x根节点的父亲
        """
        root_x, root_y = self.find(x), self.find(y)

        if root_x != root_y:
          	# root_x 接在 root_y 后面
            self.father[root_x] = root_y

    def is_connected(self,x, y):
        """
        判断两节点是否相连
        判断两个节点是否处于同一个连通分量的时候，就需要判断它们的祖先是否相同
        """
        return self.find(x) == self.find(y)
import collections

def func(accounts):
    
    # key: email, value: user_id
    # 用处：通过 email in email_id，来检测 email 有没有重复出现，
    
    
    email_id = {}  
    
    uf = UnionFind()
    for user_id in range(len(accounts)):
        # 每个用户id进入并查集
        uf.add(user_id)

    for user_id, account in enumerate(accounts):
        for email in account[1:]:
            if email in email_id:
                # 如果重复出现了，说明这两个user_id为同一个人，
                # 合并：将本次的user_id作为之前记录在email_id中user_id的父亲
                uf.merge(email_id[email], user_id)
            else:
                # 如果没出现了，在这个字典中记录，value为这个email的user_id
                email_id[email] = user_id
    # 遍历结束后，
    # 并查集uf中，都会指向共同的user_id
    # 字典email_id中，记录了每个email的父亲

    # key: id (user index), value: email list
    id_email = collections.defaultdict(list)
    for e, i in email_id.items():
        id_email[uf.find(i)].append(e)  # 注意这里id_email的key

    return [[accounts[i][0]] + sorted(e) for i, e in id_email.items()]


accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], 
["John", "johnnybravo@mail.com"], 
["John", "johnsmith@mail.com", "john_newyork@mail.com"], 
["Mary", "mary@mail.com"]]
func(accounts)

```
# bfs

 def accountsMerge(self, accounts):
        from collections import defaultdict, deque
        graph = defaultdict(set)
        email_to_name = defaultdict()
        for account in accounts:
            name = account[0]
            emails = account[1:]
            for email in emails:
                email_to_name[email] = name
                graph[emails[0]].add(email)
                graph[email].add(emails[0])
        # print(graph)
        visited = set()
        res = []

        def bfs(e):
            ans = []
            stack = deque()
            stack.appendleft(e)
            while stack:
                tmp = stack.pop()
                ans.append(tmp)
                for t in graph[tmp]:
    
                    if t not in visited:
                        visited.add(t)
                        stack.appendleft(t)
            return ans
    
        for e in graph:
            # print(e)
            if e not in visited:
                visited.add(e)
                ans = bfs(e)
                res.append([email_to_name[e]] + sorted(ans))
        return res
# dfs

    def accountsMerge(self, accounts):
        from collections import defaultdict, deque
        graph = defaultdict(set)
        email_to_name = defaultdict()
        for account in accounts:
            name = account[0]
            emails = account[1:]
            for email in emails:
                email_to_name[email] = name
                graph[emails[0]].add(email)
                graph[email].add(emails[0])
        # print(graph)
        visited = set()
        res = []
        def dfs(e):
            new_list.append(e)
            for t in graph[e]:
                if t not in visited:
                    visited.add(t)
                    dfs(t)
        for e in graph:
            if e not in visited:
                visited.add(e)
                new_list = []
                dfs(e)
                res.append([email_to_name[e]] + sorted(new_list))
        return res
# 集合

    def accountsMerge(self, accounts):
        from collections import defaultdict
        if not accounts:
            return
        lookup = defaultdict(list)
        res = []
        for account in accounts:
            name = account[0]
            email = set(account[1:])
    
            lookup[name].append(email)
            for e in lookup[name][:-1]:
                if e & email:
                    lookup[name].remove(e)
                    lookup[name][-1].update(e)
        for key, val in lookup.items():
    
            for tmp in val:
                res.append([key] + list(sorted(tmp)))
        return res
