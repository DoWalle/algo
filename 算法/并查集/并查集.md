[https://leetcode-cn.com/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/](https://leetcode-cn.com/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/)

### 基本概念

1. 并查集是一种数据结构
2. 并查集这三个字，一个字代表一个意思。
3. 并（Union），代表合并
4. 查（Find），代表查找
5. 集（Set），代表这是一个以字典为基础的数据结构，它的基本功能是合并集合中的元素，查找集合中的元素
6. 并查集的典型应用是有关连通分量的问题
7. 并查集解决单个问题（添加，合并，查找）的时间复杂度都是O(1)
8. 因此，并查集可以应用到在线算法中
### 并查集的模版

```python
class UnionFind:
    def __init__(self):
        """
        记录每个节点的父节点
        """
        self.father = {}

    def add(self,x):
        """
        添加新节点
        当把一个新节点添加到并查集中，它的父节点应该为空
        """
        if x not in self.father:
            self.father[x] = None
    
    def find(self,x):
        """
        查找根节点，如果节点的父节点不为空，那就不断迭代。
        路径压缩：
        1、如果我们树很深，比如说退化成链表，那么每次查询的效率都会非常低。所以我们要做一下路径压缩。也就是把树的深度固定为二。
        2、这么做可行的原因是，并查集只是记录了节点之间的连通关系，而节点相互连通只需要有一个相同的祖先就可以了。
        3、路径压缩可以用递归，也可以迭代。这里用迭代的方法。
        """
        root = x

        while self.father[root] != None:
            root = self.father[root]

        # 路径压缩
        while x != root:
            original_father = self.father[x]
            self.father[x] = root
            x = original_father
         
        return root
    
    def merge(self,x,y,val):
        """
        合并两个节点
        """
        root_x,root_y = self.find(x),self.find(y)
        
        if root_x != root_y:
            self.father[root_x] = root_y

    def is_connected(self,x,y):
        """
        判断两节点是否相连
        判断两个节点是否处于同一个连通分量的时候，就需要判断它们的祖先是否相同
        """
        return self.find(x) == self.find(y)
    



```

