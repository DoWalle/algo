https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/

方法一：环状替换

我们从位置 0 开始，最初令 temp=nums[0]。根据规则，位置 0 的元素会放至 (0+k)modn 的位置，令 x=(0+k)modn，此时交换 temp 和 nums[x]，完成位置 x 的更新。然后，我们考察位置 x，并交换 temp 和 nums[(x+k)modn]，从而完成下一个位置的更新。不断进行上述过程，直至回到初始位置0。

容易发现，当回到初始位置 0 时，有些数字可能还没有遍历到，此时我们应该从下一个数字开始重复的过程，可是这个时候怎么才算遍历结束呢？**进行遍历的次数为 n k 的最大公约数**

时间复杂度：O(n)  空间复杂度：O(1)

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        sz = len(nums)
        k = k % sz
        count = self.gcd(k, sz)

        start = 0
        while start < count:
            cur = start
            prev = nums[start]

            while True:
                next = (cur + k) % sz
                nums[next], prev = prev, nums[next]
                cur = next
                if start == cur:
                    break
            start += 1

    def gcd(self, a, b):
        # 最大公约数
        while a != 0:
            a, b = b%a, a
        return b
```

方法二：使用额外的数组

时间复杂度：O(n)  空间复杂度：O(n)

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        sz = len(nums)
        step = k % sz
        # print(step)
        tmp = []
        for i in range(sz):
            new_idx = (i + step) % sz
            # print(new_idx, nums[i])
            tmp.append((new_idx, nums[i]))
        for t in tmp:
            nums[t[0]] = t[1]

```