#### [5924. 网格图中机器人回家的最小代价](https://leetcode-cn.com/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/)

最小代价就是从start直接走到target，而且不同走的方式所需要的cost也是一样的

**如果说不同走的方式所需要的cost不同，那就要用记忆化的dfs**

比赛的时候先想到记忆化的bfs，`mem[r][c]`记录走到`[r][c]`的最短距离，因为记忆化的bfs还是要不断更新`mem[r][c]`的最短距离，还是很容易超时。

再想到记忆化的dfs，`mem[r][c]`记录从`[r][c]`到终点的最短距离，但是代码好像没写对。。。

```python
class Solution:
    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:
        cost = 0
        while startPos[0] != homePos[0]:
            if startPos[0] < homePos[0]:
                startPos[0] += 1
            else:
                startPos[0] -= 1
            cost += rowCosts[startPos[0]]

        while startPos[1] != homePos[1]:
            if startPos[1] < homePos[1]:
                startPos[1] += 1
            else:
                startPos[1] -= 1
            cost += colCosts[startPos[1]]
        
        return cost
```

