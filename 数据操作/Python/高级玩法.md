# 高级玩法

## 带默认值的字典

初始化一个字典，字典的值是 list / int

好处是有新的key的时候可以直接往value里面添加，不用初始化

取值的时候如果key不在里面，则返回 [] / 0

```python
import collections

d = collections.defaultdict(list)
for i in range(3):
		d[i].append("a")
    d[i].append("b")

# {0: ['a','b'], 1: ['a','b'], 2: ['a','b']
```



## 列表计数

统计列表里面每个值出现的次数，返回一个字典，value为次数

```python
import collections
cnt = collections.Counter([1,5,4,1,6,5])
# {1: 2, 5: 2, 4: 1, 6: 1}
```



## [双端队列](https://www.cnblogs.com/lincappu/p/12890765.html)

![deque](./doc/deque.png)

deque是双端队列（double-ended queue）的缩写

由于两端都能编辑，deque既可以**用来实现栈（stack）**也可以用来**实现队列（queue）**

deque在出队（pop）和入队（append）时的**时间复杂度是O(1)

而 list 在出队和插入时的时间复杂度大约为O(n)

```python
import collections

q = collections.deque([1, 2, 3, 4])	# deque([1, 2, 3, 4])

q.appendleft(99)			# deque([99, 1, 2, 3, 4])
q.append(88)					# deque([99, 1, 2, 3, 4, 88])

q.extendleft([1, 2]) 	# deque([2, 1, 99, 1, 2, 3, 4, 88])
q.extend([3, 4])			# deque([2, 1, 99, 1, 2, 3, 4, 88, 3, 4])

q.popleft()						# deque([1, 99, 1, 2, 3, 4, 88, 3, 4]) 输出 2
q.pop()								# deque([1, 99, 1, 2, 3, 4, 88, 3]) 输出 4

q.rotate(1)						# deque([3, 1, 99, 1, 2, 3, 4, 88]) 顺时针旋转一个长度
q.rotate(-1)					# deque([1, 99, 1, 2, 3, 4, 88, 3]) 逆时针旋转一个长度
```



## 对list里的元素分组

元素为列表

```python
from itertools import groupby

meetings = [["dodo",2,5],["koko",3,8],["gogo",5,10],["jojo",8,5],["bobo",4,10]]
meetings.sort(key=lambda x: x[2]) # 先对指定字段进行排序，才能使用 groupby
# [['dodo', 2, 5], ['jojo', 8, 5], ['koko', 3, 8], ['gogo', 5, 10], ['bobo', 4, 10]]
for i, members in groupby(meetings, key=lambda x: x[2]):
    print(i)
    for m in members:
        print(m)
"""
5
['dodo', 2, 5]
['jojo', 8, 5]
8
['koko', 3, 8]
10
['gogo', 5, 10]
['bobo', 4, 10]
"""
```

元素为字典

```python
from itertools import groupby

meetings = [
    {"name": "张三", "age": 20, "country": "China"},
    {"name": "李四", "age": 21, "country": "China"},
    {"name": "Tom", "age": 20, "country": "USA"}
]
meetings.sort(key=lambda x: x["age"]) # 先对指定字段进行排序，才能使用 groupby
# [{'name': '张三', 'age': 20, 'country': 'China'}, 
# {'name': 'Tom', 'age': 20, 'country': 'USA'}, 
# {'name': '李四', 'age': 21, 'country': 'China'}]
for i, members in groupby(meetings, key=lambda x: x["age"]):
    print(i)
    for m in members:
        print(m)
"""
20
{'name': '张三', 'age': 20, 'country': 'China'}
{'name': 'Tom', 'age': 20, 'country': 'USA'}
21
{'name': '李四', 'age': 21, 'country': 'China'}
"""
```

## [二分算法](https://blog.csdn.net/qq_39478403/article/details/105373620)

bisect 包，它是实现了 二分 (bisection) 算法的模块，能够保持序列 sequence 顺序不变的情况下对其进行二分查找和插入。

支持 list，还有 string 和 tuple

**查找 返回要插入的位置**

```python
import bisect
a = [1, 2, 2, 3, 4, 5]

# 若序列 a 中存在与 x 相同的元素，则返回与 x 相同的第一个 (最左侧) 元素的位置索引，使得 x 若插入后能位于其 左侧
# 若序列 a 中不存在与 x 相同的元素，则返回与 x 右侧距离最近的元素位置索引，使得 x 若插入后能位于其 左侧
bisect.bisect_left(a, 2)    # 1
bisect.bisect_left(a, 1.5)  # 1
bisect.bisect_left(a, 6)    # 6

# 若序列 a 中存在与 x 相同的元素，则返回与 x 相同的最后一个(最右侧)元素的位置索引加一
# 若序列 a 中不存在与 x 相同的元素，则返回与 x 左侧距离最近的元素位置索引加一，使得 x 若插入后能位于其右侧。
bisect.bisect_right(a, 2)   # 3
bisect.bisect_right(a, 1.5) # 1
bisect.bisect_right(a, 6)   # 6

bisect.bisect(a, 2) # 3 和 bisect_right 一样
```

**插入，原地址插入，无返回值，insort_left和bisect_right最终体现的结果一样**

```python
import bisect
a = [1, 2, 2, 3]

# 元素 x 的插入点 (左侧)，将元素插入
bisect.insort_left(a, 2)    # [1, 2, 2, 2, 3]
bisect.insort_left(a, 1.5)  # [1, 1.5, 2, 2, 3]

# 元素 x 的插入点 (右侧)，将元素插入
bisect.bisect_right(a, 2)   # [1, 2, 2, 2, 3] 和 insort_right 一样

bisect.insort(a, 2)	    # insort_right 一样
```

http://www.grantjenks.com/docs/sortedcontainers/

from sortedcontainers import SortedList
list = [1, 5, 2, 4]
sl = SortedList(list)
sl.add(3)
sl.add(3)
print(sl) # SortedList([1, 2, 3, 3, 4, 5])

# 指定值来获取在红黑树中的下标
l_idx = sl.bisect_left(3)
r_idx = sl.bisect_right(3)
print(l_idx, r_idx) # 2 4
