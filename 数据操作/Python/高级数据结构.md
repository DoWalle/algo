## 带默认的字典

初始化一个字典，字典的值是 list / int

好处是有新的key的时候可以直接往value里面添加，不用初始化

取值的时候如果key不在里面，则返回 [] / 0

```python
import collections

d = collections.defaultdict(list)
for i in range(3):
		d[i].append("a")
    d[i].append("b")

# {0: ['a','b'], 1: ['a','b'], 2: ['a','b']
```



## 列表计数

统计列表里面每个值出现的次数，返回一个字典，value为次数

```python
import collections
cnt = collections.Counter([1,5,4,1,6,5])
# {1: 2, 5: 2, 4: 1, 6: 1}
```



## [双端队列](https://www.cnblogs.com/lincappu/p/12890765.html)

![deque](./doc/deque.png)

deque是双端队列（double-ended queue）的缩写

由于两端都能编辑，deque既可以**用来实现栈（stack）**也可以用来**实现队列（queue）**

deque在出队（pop）和入队（append）时的**时间复杂度是O(1)

而 list 在出队和插入时的时间复杂度大约为O(n)

```python
import collections

q = collections.deque([1, 2, 3, 4])	# deque([1, 2, 3, 4])

q.appendleft(99)			# deque([99, 1, 2, 3, 4])
q.append(88)					# deque([99, 1, 2, 3, 4, 88])

q.extendleft([1, 2]) 	# deque([2, 1, 99, 1, 2, 3, 4, 88])
q.extend([3, 4])			# deque([2, 1, 99, 1, 2, 3, 4, 88, 3, 4])

q.popleft()						# deque([1, 99, 1, 2, 3, 4, 88, 3, 4]) 输出 2
q.pop()								# deque([1, 99, 1, 2, 3, 4, 88, 3]) 输出 4

q.rotate(1)						# deque([3, 1, 99, 1, 2, 3, 4, 88]) 顺时针旋转一个长度
q.rotate(-1)					# deque([1, 99, 1, 2, 3, 4, 88, 3]) 逆时针旋转一个长度
```



## [优先队列 & 堆](https://oi-wiki.org/ds/heap/)

堆（二叉堆）是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于/小于等于其父亲的键值。

每个节点的键值都大于等于其父亲键值的堆叫做小根堆，否则叫做大根堆。

一些功能强大的堆（可并堆）还能（高效地）支持 merge 等操作。支持可持久化，也就是对任意历史版本进行查询或者操作，产生新的版本。

**缺点是不支持删除任意一个值**

**（小根）堆主要支持的操作及时间复杂度：**

插入一个数 O(log n)

查询最小值 O(1)

删除最小值 O(log n)

合并两个堆 O(n)

减小一个元素的值 O(log n)

#### [python用法](https://www.jianshu.com/p/801318c77ab5)

**创建 & 访问 & 删除**

heapq创建的是小根堆

```python
import heapq

# 第一种创建方式
nums = [2, 3, 5, 1, 54, 23, 132]
heap = []
for num in nums:
    heapq.heappush(heap, num)  # 加入堆 

print(heap[0])  # 1 如果只是想获取最小值而不是弹出，使用heap[0]
print([heapq.heappop(heap) for _ in range(len(nums))])
# out: [1, 2, 3, 5, 23, 54, 132]
# 注：不要直接去看 heap，因为heap的顺序是二叉堆的某种排序，
# 当heapq.heappop 时才会由小及大弹出数据


# 第二种创建方式
nums = [2, 3, 5, 1, 54, 23, 132]
heapq.heapify(nums)

# 如果需要删除堆中最小元素并加入一个元素，
heapq.heapreplace(nums, 10)
# 堆排序结果 [2, 3, 5, 10, 23, 54, 132]

# 获取堆最大或最小值，不常用
print(heapq.nlargest(4, nums)) 	# [132, 54, 23, 10]
print(heapq.nsmallest(4, nums))	# [2, 3, 5, 10]
```

**带权值的优先队列**

```python
import heapq

# 小根堆用法
priorityQueue = [] 

# 第一个参数是值，作为优先级，第二个值可以存权值
heapq.heappush(priorityQueue, (5, 'write code')) 
heapq.heappush(priorityQueue, (7, 'release product'))
heapq.heappush(priorityQueue, (1, 'write spec'))
heapq.heappush(priorityQueue, (3, 'create tests'))

v, s = heapq.heappop(priorityQueue) 
# v:1 s:"write spec"
print([heapq.heappop(priorityQueue) for _ in range(len(priorityQueue))])
# [(3, 'create tests'), (5, 'write code'), (7, 'release product')]
```

**实现大根堆**

若想用大根堆，值先转化为负的大的变小的，放进去；取出来后，再把负的转化为正的，小的变大

```python
import heapq

nums = [2, 3, 5, 1, 54, 23, 132]
heap = []
for num in nums:
  heapq.heappush(heap, -num) 
  
print([-heapq.heappop(heap) for _ in range(len(nums))])
# [132, 54, 23, 5, 3, 2, 1]
```

**某种意义上的合并**

heapq 模块还有一个`heapq.merge(*iterables)` 方法，用于合并多个排序后的序列成一个排序后的序列， 返回排序后的值的迭代器。
类似于`sorted(itertools.chain(*iterables))`，但返回的是可迭代的。

```python
import heapq

num1 = [32, 3, 5, 34, 54, 23, 132]
num2 = [23, 2, 12, 656, 324, 23, 54]
num1 = sorted(num1)
num2 = sorted(num2)

# merge 传入的参数必须是排过续的列表，没有排序或者传入的是个堆都不行
res = heapq.merge(num1, num2)
print(list(res))
# out: [3, 3, 5, 5, 23, 23, 32, 32, 34, 34, 54, 54, 132, 132]
```



## 有序序列 & 红黑树

#### [python用法](https://www.jianshu.com/p/801318c77ab5)

**创建**

```python
from sortedcontainers import SortedList

sl = SortedList()
for i in [3, 1, 2]:
    sl.add(i) # 添加新元素并排序。时间复杂度O(log(n))
# SortedList([1, 2, 3])

# 添加的可迭代对象并排序。时间复杂度O(k*log(n))
sl.update([6, 5, 4, 4])     # SortedList([1, 2, 3, 4, 4, 5, 6])
```

**查找**

```python
# 查找指定值的下标，如果这个value已经存在，则返回所有相同values的左端下标.
# 不存在时，返回可能位置的下标
# 时间复杂度O(log(n))
idx = sl.bisect_left(4)     # 3
idx = sl.bisect_left(4.4)   # 5

# 查找右端，返回所有相同values的右端下标+1
# 时间复杂度O(log(n))
idx = sl.bisect_right(4)    # 5

# 查找元素出现的次数。时间复杂度O(log(n))
cnt = sl.count(4)           # 2

# 查找索引范围[start,stop）内第一次出现value的索引，如果value不存在，报错ValueError. 
# 时间复杂度O(log(n))
idx = sl.index(4, start=None, stop=None) # 3
```

**删除**

```python
# 移除一个值元素，如果元素不存在，报错ValueError。时间复杂度O(log(n)).
sl.remove(3)        # SortedList([1, 2, 4, 4, 5, 6])

# 移除一个值元素，如果元素不存在，不报错。时间复杂度O(log(n))
sl.discard(99)      # SortedList([1, 2, 4, 4, 5, 6])

# 移除一个指定下标元素，如果有序序列为空或者下标超限，报错IndexError. 时间复杂度O(log(n)
sl.pop(index=-1)    # SortedList([1, 2, 4, 4, 5])

# 移除所有元素。时间复杂度O(n).
sl.clear()          # SortedList([])
```

