# [最短路径](https://oi-wiki.org/graph/shortest-path/#dijkstra)

n为图上点的数目，

m 为图上边的数目 

s 为最短路径的源点 

D(u)为s点到u点的实际最短路径长度 

dis(u) 为s点到u点的估计最短长度，任何时候都有dis(u)大于等于D(u)，

当最短算法结束时，应有dis(u)等于D(u) 

w(u, v) 为 (u, v) 这一条边的权值

| 最短路算法       | Floyd                | Bellman-Ford | Dijkstra   | Johnson              |
| ---------------- | -------------------- | ------------ | ---------- | -------------------- |
| 最短路类型       | 每对结点之间的最短路 | 单源最短路   | 单源最短路 | 每对结点之间的最短路 |
| 作用于           | 任意图               | 任意图       | 非负权图   | 任意图               |
| 能否检测负环？   | 能                   | 能           | 不能       | 能                   |
| 推荐作用图的大小 | 小                   | 中/小        | 大/中      | 大/中                |
| 时间复杂度       | *O(N^3)*             | *O(NM)*      | *O(MlogM)* | *O(NMlogM)*          |

## dijkstra

```python
# 邻接矩阵
inf = float("inf")
adj = [
    [0, 1, 12, inf, inf, inf],
    [inf, 0, 9, 3, inf, inf],
    [inf, inf, 0, inf, 5, inf],
    [inf, inf, 4, 0, 13, 15],
    [inf, inf, inf, inf, 0, 4],
    [inf, inf, inf, inf, inf, 0]
]
```

**方法一：暴力法**

时间复杂度：`O(n^2)`

```python
# https://zhuanlan.zhihu.com/p/63395403
def dijkstraBL(start, adj):
    passed = [start]
    nopass = [x for x in range(len(adj)) if x != start]
    dis = adj[start]

    while nopass:
        # 初始化 源点start 到 nopass 中最近的那个点
        idx = nopass[0]
        # 从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径
        for i in nopass:
            if dis[i] < dis[idx]:
                idx = i
        
        nopass.remove(idx)
        passed.append(idx)

        # 我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，
        # 如果是，那么就替换这些顶点在dis中的值
        for i in nopass:
            if dis[idx] + adj[idx][i] < dis[i]:
                dis[i] = dis[idx] + adj[idx][i]
    print(dis)
dijkstraBL(0, adj)
```

**方法二：优先队列**

时间复杂度 ：`O(mlogm)`

```python
import heapq
def dijkstra_PriorityQueue(start, adj):
    sz = len(adj)
    vis = [False for _ in range(sz)]
    dis = [float("inf") for _ in range(sz)]
    dis[start] = 0

    q = []
    heapq.heappush(q, (dis[start], start)) # 左边是优先级, 右边是点

    while q:
        _, cur = heapq.heappop(q)
        if vis[cur]:
            # 优先队列pop出的为最小值，已经确定的值，下次不用再走了
            continue
        vis[cur] = True
        for n_node in range(sz):
            tmp = dis[cur] + adj[cur][n_node]
            if tmp < dis[n_node]:
                dis[n_node] = tmp
                heapq.heappush(q, (dis[n_node], n_node))
    print(dis)
```

