# 最短路径

来源：[https://oi-wiki.org/graph/shortest-path/#dijkstra](https://oi-wiki.org/graph/shortest-path/#dijkstra)

n为图上点的数目，

m 为图上边的数目 

`start` 为最短路径的源点 

D(u)为s点到u点的实际最短路径长度 

`dis(u)` 为`start`点到`u点`的估计最短长度，任何时候都有dis(u)大于等于D(u)，

当最短算法结束时，应有dis(u)等于D(u) 

w(u, v) 为 (u, v) 这一条边的权值

| 最短路算法       | Floyd                | Bellman-Ford | Dijkstra   | Johnson              |
| ---------------- | -------------------- | ------------ | ---------- | -------------------- |
| 最短路类型       | 每对结点之间的最短路 | 单源最短路   | 单源最短路 | 每对结点之间的最短路 |
| 作用于           | 任意图               | 任意图       | 非负权图   | 任意图               |
| 能否检测负环？   | 能                   | 能           | 不能       | 能                   |
| 推荐作用图的大小 | 小                   | 中/小        | 大/中      | 大/中                |
| 时间复杂度       | *O(N^3)*             | *O(NM)*      | *O(MlogM)* | *O(NMlogM)*          |



## Dijkstra 算法

是一种求解 **非负权图** 上单源最短路径的算法，本质上是一种「贪心思想」

### 流程

将结点分成两个集合：**已确定最短路长度的点集 `visited`**，**未确定最短路长度的点集 `queue`**，一开始所有的点都属于 `queue` 集合

**`dis` 列表中保存从起点 `start` 到目标点的「估计最短距离」**，在算法结束后会被更新为「实际最短路径」

初始化：起点 `start` 进入 `visited`，其余点进入 `queue`，在 `dis` 列表中记录 `dis[start]=0`

while `queue` 集合不为空：

1. 从 `queue` 集合中选取一个最短路长度最小的结点，移到 `visited` 集合中
2. 对刚加入 `visited` 集合的结点的所有出边执行松弛操作。如果该点到达其他点的路径长度比源点直接到达短，那么就替换这些顶点在dis中的值为「先从源点到该点再到其他点」



**问题一：**[松弛是什么意思?](https://www.zhihu.com/question/306895915)

可以想像图是用毛线和珠子组成的网状结构，两颗珠子之间毛线的长度即edge上的权值，一开始十分松乱的放在桌上。

现在要求SSSP(单源最短路)，当发现从源点s到当前点u有两条路径，**relax操作可以想象成用力把s和u两点往外撑开**。

这时候依照生活经验，我们可以很自然的看到s点和u点之问**较短的那条边处于紧绷状态，而较长的那条边处于松弛状态**。

因此非常形象的把这个操作称为松弛操作。

dijkstra的松弛操作为：

![](./doc/松弛.png)

**问题二：**为什从 `queue` 集合中选取一个最短路长度最小的结点，就可以确定为源点到该点已是最短的？

「贪心思想」如果每次选的都是最短的点，通过最短点来维护后面的点也一定是最短的（安慰自己的解答）



### 方法一：优先队列

时间复杂度 ：`O(mlogm)`

```python
import heapq

def dijkstra(start, adj):
    node_sz = len(adj)
    visited = [False for _ in range(node_sz)]
    dis = [float("inf") for _ in range(node_sz)]

    dis[start] = 0
    queue = []
    # 左边是源点到该点的预估最短距离（作为优先级）, 右边是到达点
    heapq.heappush(queue, (dis[start], start)) 

    while queue:
        """
        小根堆pop出的堆顶，就是源点s到该点的最短路径
        已经确定最短距离的点，下次不用再走了
        """
        _, cur = heapq.heappop(queue)
        if visited[cur]:
            continue
        
        visited[cur] = True # 标记该点有了最短距离

        """
        松弛操作:
        看看通过该顶点到达其他点的路径长度是否比源点直接到达短
        如果是，那么就替换这些顶点在dis中的值
        """
        for n_idx in range(node_sz):
            if dis[cur] + adj[cur][n_idx] < dis[n_idx]:
                dis[n_idx] = dis[cur] + adj[cur][n_idx]
                heapq.heappush(queue, (dis[n_idx], n_idx))
    
    print(dis) # [0, 1, 8, 4, 13, 17]
```



### 方法二：暴力法

时间复杂度：`O(m^2)`

```python
# 邻接矩阵
inf = float("inf")
adj = [
    [0, 1, 12, inf, inf, inf],
    [inf, 0, 9, 3, inf, inf],
    [inf, inf, 0, inf, 5, inf],
    [inf, inf, 4, 0, 13, 15],
    [inf, inf, inf, inf, 0, 4],
    [inf, inf, inf, inf, inf, 0]
]
```

```python
def dijkstra(start, adj):
    node_sz = len(adj)
    visited = [False if n != start else True for n in range(node_sz)]
    queue = [n for n in range(node_sz) if n != start]
    dis = [adj[start][n] if n != start else 0 for n in range(node_sz)]
    """
    visited: [True, False, False, False, False, False] 在这种写法中可以不用visited
    queue:   [1, 2, 3, 4, 5]
    dis:     [0, 1, 12, inf, inf, inf]
    """

    while queue:
        """
        从 queue 集合中选取一个最短路长度最小的结点，这些权值从dis数组中找
        贪心算法，该值就是源点s到该值对应点的最短路径
        """
        idx = queue[0] # 随便在 queue 中找个点
        for i in queue:
            if dis[i] < dis[idx]:
                idx = i
        
        queue.remove(idx)
        visited[idx] = True

        """
        松弛操作:
        需要看看新加入的顶点是否可以到达其他顶点，
        并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短
        如果是，那么就替换这些顶点在dis中的值
        """
        for n_idx in queue:
            if dis[idx] + adj[idx][n_idx] < dis[n_idx]:
                dis[n_idx] = dis[idx] + adj[idx][n_idx]
    
    print(dis) # [0, 1, 8, 4, 13, 17]
```

---

`感谢`  大家点赞 Star🌟 [https://github.com/DoWalle/algorithm](https://github.com/DoWalle/algorithm) 笔芯🤞

`发布`  于 Gitbook [https://dowalle.gitbook.io/algo/](https://dowalle.gitbook.io/algo/)
