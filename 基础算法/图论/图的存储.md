# 图的存储

在本文中，用 n 代指图的点数，用 m 代指图的边数，用 d(u) 代指点 的出度，即以 u 为出发点的边数。

## 邻接表

使用一个支持动态增加元素的数据结构构成的数组，如 `vector<int> adj[n + 1]` 来存边，其中`adj[u]` 存储的是点 的所有出边的相关信息（终点、边权等）。

```python
graph = [[0, 0, 0], [0, 1, 1], [0, 2, 12],
         [1, 1, 0], [1, 2, 9], [1, 3, 3],
         [2, 2, 0], [2, 4, 5],
         [3, 2, 4], [3, 3, 0], [3, 4, 1], [3, 5, 15],
         [4, 4, 0], [4, 5, 4],
         [5, 5, 0]
        ]
adj_list = collections.defaultdict(list) # 邻接表
for u, v, q in graph:
    adj_list[u].append((v, q))

# defaultdict(<class 'list'>, {0: [(0, 0), (1, 1), (2, 12)], 1: [(1, 0), (2, 9), (3, 3)], 2: [(2, 0), (4, 5)], 3: [(2, 4), (3, 0), (4, 1), (5, 15)], 4: [(4, 0), (5, 4)], 5: [(5, 0)]})
```

### 应用

存各种图都很适合，除非有特殊需求（如需要快速查询一条边是否存在，且点数较少，可以使用邻接矩阵）。

尤其适用于需要对一个点的所有出边进行排序的场合。

### 复杂度

查询是否存在 u 到 v 的边：O(d(u)) ,如果事先进行了排序就可以使用 [二分查找](https://oi-wiki.org/basic/binary/) 做到 O(log(d(u)))

遍历点 的所有出边：O(d(u))

遍历整张图：O(n+m)

空间复杂度：O(m)

## 邻接矩阵

```python
inf = float("inf")
adj_matrix = [[inf for _ in range(6)] for _ in range(6)]
for u, v, q in graph:
    adj_matrix[u][v] = q
```

使用一个二维数组 `adj` 来存边，其中 `adj[u][v]` 为 u 到 v 的权值，正无穷表示不存在。

### 应用

邻接矩阵只适用于没有重边（或重边可以忽略）的情况。

其最显著的优点是可以 O(1) 查询一条边是否存在。

由于邻接矩阵在稀疏图上效率很低（尤其是在点数较多的图上，空间无法承受），所以一般只会在稠密图上使用邻接矩阵。

### 复杂度

查询是否存在某条边：O(1)

遍历一个点的所有出边：O(n)

遍历整张图：O(n^2)

空间复杂度：O(n^2)
