# [拓扑排序](https://oi-wiki.org/graph/topo/#kahn)

Topological sorting，在一个 [DAG 有向无环图](https://oi-wiki.org/graph/dag/) 中，将所有节点排序，使得排在前面的节点不能依赖于排在后面的节点。

一个图满足拓扑排序的条件是：

- 这个图是有向无环图
- 所有的点都是有序的，前面的点不依赖于后面的点

例如：

<img src="/Users/zhangdong/Desktop/algorithm/基础算法/图论/doc/拓扑排序.png" alt="拓扑排序" style="zoom:35%;" />

对其排序的结果就是：2 -> 8 -> 0 -> 3 -> 7 -> 1 -> 5 -> 6 -> 9 -> 4 -> 11 -> 10 -> 12



## kahn 算法

核心是维护一个入度为 0 点的队列

**算法：**

1. 创建邻接表和入度表
2. 初始状态下，所有入度为 0 的点先进入队列
3. 每次从队列中取一个入度为0的点`node`，放入topo列表中
4. 将点`node`后面的点`n_node`入度减一（表明`n_node`前面的那个点`node`被移除了）
5. 如果`n_node`的入度为0（表明`n_node`前面所有依赖的点都已经移除了），就可进入队列重复 3、4、5 过程

**注意点：**

- 不需要 visited，因为有些点需要重复走到，才可以把这些点前面依赖的点都移除（该点的入度才能从3减为0）
- 拓扑排序并不是唯一的，例如 [1,2,3,  4,5,6,  7,8,9]，三个层级内的顺序不是严格的
- 如果图中有环，`indegree[n_node] == 0`的判断可以防止环中的点被走到，最后拓扑排序中的点数量不等于所有节点的数量

```python
def isTopo(courses: List[List[int]], numCourses: int) -> bool:
    # numCourses: 课程数量
    # courses: 课程关系, [a, b] 要想学a，先学b；学完b，才能学a

    adj = collections.defaultdict(list)  # 邻接表
    indegree = collections.defaultdict(int)  # 入度表
    topo = []  # 拓扑排序

    # 1、创建邻接表和入度表
    for a, b in courses:
        adj[b].append(a)
        indegree[a] += 1

    # 2、入度为 0 的点进入队列
    queue = collections.deque([k for k in indegree if indegree[k] == 0])
    while queue:
        node = queue.popleft()
        topo.append(node)  # 3、topo中记录入度为0的点
        for n_node in adj[node]:
            # 4、走到一个点时入度减一
            indegree[n_node] -= 1
            if indegree[n_node] == 0:
            		# 5、下一个点入度为0，可进入队列
                queue.append(n_node)

    print(topo)
    return len(topo) == numCourses
```

