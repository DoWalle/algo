## [优先队列 & 堆](https://oi-wiki.org/ds/heap/)

堆（二叉堆）是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于/小于等于其父亲的键值。

每个节点的键值都大于等于其父亲键值的堆叫做小根堆，否则叫做大根堆。

一些功能强大的堆（可并堆）还能（高效地）支持 merge 等操作。支持可持久化，也就是对任意历史版本进行查询或者操作，产生新的版本。

**缺点是不支持删除任意一个值**

**（小根）堆主要支持的操作及时间复杂度：**

插入一个数 O(log n)

查询最小值 O(1)

删除最小值 O(log n)

合并两个堆 O(n)

减小一个元素的值 O(log n)

## 应用

应用场景：添加值的时候时间复杂度做到`O(log(n)) `  ，取值的时候做到`O(1)`

**但堆仅方便操作堆顶的值，怎样能让堆也方便的操作中间某个元素呢，通过维护两个堆（大、小根堆）的大小。一般来说，一个由小到大的序列，左边维护成大根堆，右边维护成小根堆，也就是大根堆的最大值 <= 小根堆的最小值**

<img src="./doc/大小根堆.png" alt="大小根堆" style="zoom:50%;" />

### 例题

[295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/) [5937. 序列顺序查询](https://leetcode-cn.com/problems/sequentially-ordinal-rank-tracker/) 都是维护两个堆（大、小根堆）的大小

### [Python用法](https://www.jianshu.com/p/801318c77ab5)

**创建 & 访问 & 删除**

heapq创建的是小根堆

```python
import heapq

# 第一种创建方式
nums = [2, 3, 5, 1, 54, 23, 132]
heap = []
for num in nums:
    heapq.heappush(heap, num)  # 加入堆 

print(heap[0])  # 1 如果只是想获取最小值而不是弹出，使用heap[0]
print([heapq.heappop(heap) for _ in range(len(nums))])
# out: [1, 2, 3, 5, 23, 54, 132]
# 注：不要直接去看 heap，因为heap的顺序是二叉堆的某种排序，
# 当heapq.heappop 时才会由小及大弹出数据


# 第二种创建方式
nums = [2, 3, 5, 1, 54, 23, 132]
heapq.heapify(nums)

# 如果需要删除堆中最小元素并加入一个元素，
heapq.heapreplace(nums, 10)
# 堆排序结果 [2, 3, 5, 10, 23, 54, 132]

# 获取堆最大或最小值，不常用
print(heapq.nlargest(4, nums)) 	# [132, 54, 23, 10]
print(heapq.nsmallest(4, nums))	# [2, 3, 5, 10]
```



**带权值的优先队列，也可作为多级排序**

```python
import heapq

# 小根堆用法
priorityQueue = [] 

# 第一个参数是值，作为优先级，第二个值可以存权值
heapq.heappush(priorityQueue, (5, 'write code')) 
heapq.heappush(priorityQueue, (7, 'release product'))
heapq.heappush(priorityQueue, (1, 'write spec'))
heapq.heappush(priorityQueue, (3, 'create tests'))

v, s = heapq.heappop(priorityQueue) 
# v:1 s:"write spec"
print([heapq.heappop(priorityQueue) for _ in range(len(priorityQueue))])
# [(3, 'create tests'), (5, 'write code'), (7, 'release product')]

hp = [] 
heapq.heappush(hp, (1, 'a')) 
heapq.heappush(hp, (2, 'ab'))
heapq.heappush(hp, (3, 'ac'))
heapq.heappush(hp, (3, 'cb'))

print([heapq.heappop(hp) for _ in range(len(hp))])
# [(1, 'a'), (2, 'ab'), (2, 'ac'), (2, 'cb')]
# 可以看到当第一项相同时，第二项为字典序
```



**实现大根堆**

若想用大根堆，值先转化为负的大的变小的，放进去；取出来后，再把负的转化为正的，小的变大

```python
import heapq

nums = [2, 3, 5, 1, 54, 23, 132]
heap = []
for num in nums:
  heapq.heappush(heap, -num) 
  
print([-heapq.heappop(heap) for _ in range(len(nums))])
# [132, 54, 23, 5, 3, 2, 1]
```



**如果堆中的元素是对象的话，可以参照 [高级玩法-重载运算符](../../数据操作/Python/高级玩法.md)**



**封装用法 支持大小根堆，不支持带权值，经过多次比赛感觉不如直接写来的自然**

```python
import heapq

class Heap:
    def __init__(self, name="small"):
        self.arr = []
        self.transform = lambda x: x if name=="small" else -x

    def push(self, num):
        # 推入一个
        heapq.heappush(self.arr, self.transform(num))

    def pop(self):
        # 弹出堆顶
        return self.transform(heapq.heappop(self.arr))

    @property
    def top(self):
        # 获取堆顶元素
        return self.transform(self.arr[0])
    
    @property
    def length(self):
        return len(self.arr)
    
    @property
    def isEmpty(self):
        return len(self.arr) == 0
```



**某种意义上的合并**

heapq 模块还有一个`heapq.merge(*iterables)` 方法，用于合并多个排序后的序列成一个排序后的序列， 返回排序后的值的迭代器。
类似于`sorted(itertools.chain(*iterables))`，但返回的是可迭代的。

```python
import heapq

num1 = [32, 3, 5, 34, 54, 23, 132]
num2 = [23, 2, 12, 656, 324, 23, 54]
num1 = sorted(num1)
num2 = sorted(num2)

# merge 传入的参数必须是排过续的列表，没有排序或者传入的是个堆都不行
res = heapq.merge(num1, num2)
print(list(res))
# out: [3, 3, 5, 5, 23, 23, 32, 32, 34, 34, 54, 54, 132, 132]
```
