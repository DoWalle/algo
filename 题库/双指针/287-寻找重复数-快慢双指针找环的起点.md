#### [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

**方法一：快慢双指针 + 查找指针**

思路：

数组形式的链表。题目设定的问题是 N+1 个元素都在 [1,n] 这个范围内。、将这个题目给的特殊的数组当作一个链表来看，数组的下标就是指向元素的指针，把数组的元素也看作指针。如 0 是指针，指向 nums[0]，而 nums[0] 也是指针，指向 nums[nums[0]].

我们先设置慢指针 slow 和快指针 fast ，慢指针每次走一步，快指针每次走两步，根据**「Floyd 判圈算法」**两个指针在有环的情况下一定会相遇，此时我们再将 finder 放置起点 0，slow 和 finder 两个指针每次同时移动一步，相遇的点就是答案。

证明：

<img src="./环.png" alt="iShot2021-11-21 16.28.27" style="zoom: 33%;" />

假设环长为 L，从起点到环的入口的步数是 a，从环的入口继续走 b 步到达相遇位置，从相遇位置继续走 c 步回到环的入口，则有 **L=b+c**  ，其中 L、a、b、c 都是正整数。根据上述定义，慢指针走了 a+b 步，快指针走了 2(a+b) 步。从另一个角度考虑，在相遇位置，快指针比慢指针多走了若干圈，因此快指针走的步数还可以表示成 a+b+kL，其中 k 表示快指针比慢指针在环上多走的圈数。联立等式，可以得到
$$
2(a + b) = a + b + kL
$$

因为  **L=b+c**，所以
$$
\begin{aligned}
a &= -b + kL \\
&= c + (1-k)L
\end{aligned}
$$
从上述等式可知，如果**查找指针**从起点出发，**慢指针**从相遇位置继续出发，每次两个指针都移动一步，则**查找指针**走了a 步之后到达环的入口。**慢指针**在环里从相遇位置走了 c 步和 k−1 圈，到环的入口。**查找指针**和**慢指针**在环的入口相遇，相遇点就是答案。

**分两步：**

**第一步找到慢指针 slow 和快指针 fast 在环内的相遇点**

**第二步查找指针在原点和慢指针在相遇点同时出发，会在环的入口相遇**


时间复杂度：O(n)  空间复杂度：O(1)

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow = 0
        fast = 0
        while True:
            fast = nums[nums[fast]]
            slow = nums[slow]
            if fast == slow:
                break

        finder = 0
        while True:
            finder = nums[finder]
            slow = nums[slow]
            if slow == finder:
                break
        return slow
```

拓展：怎样得到环的长度？

快指针不动，慢指针开始走动，记录走的距离，当遇到快指针的时候就得到环的长度



**方法二：走过的放入集合**

时间复杂度：O(n)  空间复杂度：O(n)

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        s = set()
        for n in nums:
            if n not in s:
                s.add(n)
            else:
                return n
```

