#### [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

给定两个数组，编写一个函数来计算它们的交集。

方法一：排序 + 双指针

时间复杂度：O(mlogm + nlogn) + O(m+n)

空间复杂度：O(mlogm + nlogn) 主要取决于排序使用的额外空间

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1.sort()
        nums2.sort()
        sz1 = len(nums1)
        sz2 = len(nums2)
        p1 = 0
        p2 = 0

        ans = []
        while p1 < sz1 and p2 < sz2:
            cur1 = nums1[p1]
            cur2 = nums2[p2]
            if cur1 == cur2:
                # 保证加入元素的唯一性
                if not ans or cur1 != ans[-1]:
                    ans.append(cur1)
                p1 += 1
                p2 += 1
            elif cur1 < cur2:
                p1 += 1
            else:
                p2 += 1
        return ans

```



方法二：两个集合

时间复杂度：O(m+n) + O(min(m,n)) 

空间复杂度：O(m+n)

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        n1 = set(nums1)
        n2 = set(nums2)
        return self.jiaoji(n1, n2)
    
    def jiaoji(self, n1, n2):
        if len(n1) > len(n2):
            return self.jiaoji(n2, n1)
        return [i for i in n1 if i in n2]
```

#### [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

方法一：排序 + 双指针

给定两个数组，编写一个函数来计算它们的交集。输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致

```python
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1.sort()
        nums2.sort()
        sz1 = len(nums1)
        sz2 = len(nums2)
        p1 = 0
        p2 = 0

        ans = []
        while p1 < sz1 and p2 < sz2:
            cur1 = nums1[p1]
            cur2 = nums2[p2]
            if cur1 == cur2:
                ans.append(cur1)
                p1 += 1
                p2 += 1
            elif cur1 < cur2:
                p1 += 1
            else:
                p2 += 1
        return ans
```

方法二：哈希表

首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数。

为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集。

时间复杂度：O(m+n)

空间复杂度：O(min⁡(m,n))

```python
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:

        if len(nums1) > len(nums2):
            return self.intersect(nums2, nums1)
        short_dict = collections.Counter(nums1)
        
        ans = []
        for n in nums2:
            if short_dict.get(n, 0) > 0:
                ans.append(n)
                short_dict[n] -= 1
        return ans
```

