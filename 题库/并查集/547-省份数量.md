#### 方法一：并查集

```python
class UnionFind:
    def __init__(self):
        self.father = {}
        # 额外记录集合的数量
        self.num_of_sets = 0

    def find(self, x):
        root = x

        while self.father[root] != None:
            root = self.father[root]

        while x != root:
            original_father = self.father[x]
            self.father[x] = root
            x = original_father

        return root

    def merge(self, x, y):
        root_x, root_y = self.find(x), self.find(y)

        if root_x != root_y:
            self.father[root_x] = root_y
            # 集合的数量-1
            self.num_of_sets -= 1

    def add(self, x):
        if x not in self.father:
            self.father[x] = None
            # 集合的数量+1
            self.num_of_sets += 1

class Solution:
    def run(self, isConnected):
        uf = UnionFind()
        cities = len(isConnected)
        for i in range(cities):
            uf.add(i)
            for j in range(i): # 无向图，只用扫描一半就好了
                if isConnected[i][j] == 1:
                    uf.merge(i, j)

        return uf.num_of_sets
```

#### 
#### 方法二：深度优先搜索

深度优先搜索的思路是很直观的。遍历所有城市，对于每个城市，如果该城市尚未被访问过，则从该城市开始深度优先搜索，通过矩阵 

isConnected

isConnected 得到与该城市直接相连的城市有哪些，这些城市和该城市属于同一个连通分量，然后对这些城市继续深度优先搜索，直到同一个连通分量的所有城市都被访问到，即可得到一个省份。遍历完全部城市以后，即可得到连通分量的总数，即省份的总数。

```python
class Solution:
    def run(self, isConnected):
        cities = len(isConnected)

        def dfs(i):
            for j in range(cities):
                if isConnected[i][j] == 1 and j not in visited:
                    visited.add(j)
                    dfs(j)

        visited = set()
        ans = 0
        for i in range(cities):
            if i not in visited:
                dfs(i)
                ans += 1
        return ans
```
      
#### 方法三：广度优先搜索

也可以通过广度优先搜索的方法得到省份的总数。对于每个城市，如果该城市尚未被访问过，则从该城市开始广度优先搜索，直到同一个连通分量中的所有城市都被访问到，即可得到一个省份。

```python
class Solution:
    def run(self, isConnected):
        cities = len(isConnected)

        def bfs(i):
            queue = [i]
            while queue:
                j = queue.pop(0)
                visited.add(j)
                for k in range(cities):
                    if isConnected[j][k] == 1 and k not in visited:
                        queue.append(k)

        visited = set()
        ans = 0
        for i in range(cities):
            if i not in visited:
                bfs(i)
                ans += 1
        return ans
```


#### 


