首先,我们理解题意,有个列表,列表中每一个元素由人名和邮箱组成.有重名的可能是一个人,也可能不是一个人.我们通过他们是否有相同邮箱来判定到底是不是同一个人.目标:是缩减这个列表,使同一个人邮箱(按字典顺序)合并在一起.

接下来我们考虑方法,其实最容易的想的就是集合操作,就是说两个同名的邮箱有重叠部分说明就是同一人,我们合并起来.

另一种思考就是,用图.我们把同一个人的邮箱连起来,找一个人所有的邮箱,就是找到他的连通分量.所有,这里就有3种方法,dfs,bfs,并查集.

# 并查集

    def accountsMerge(self, accounts):
        from collections import defaultdict

        f = {}

        def find(x):
            f.setdefault(x, x)
            while f[x] != x:
                #x = f[x]
                f[x] = f[f[x]]
                x = f[x]
            return x

        def union(x, y):
            f[find(x)] = find(y)

        lookup = {}
        n = len(accounts)
        for idx, account in enumerate(accounts):
            name = account[0]
            email = account[1:]
            for e in email:
                if e in lookup:
                    union(idx, lookup[e])
                else:
                    lookup[e] = idx
        # print(f)
        disjointSet = defaultdict(set)
        for i in range(n):
            tmp = find(i)
            for es in accounts[i][1:]:
                disjointSet[tmp].add(es)
        # print(disjointSet)
        res = []
        for key, val in disjointSet.items():
            res.append([accounts[key][0]] + list(sorted(val)))
        return res    
# bfs

 def accountsMerge(self, accounts):
        from collections import defaultdict, deque
        graph = defaultdict(set)
        email_to_name = defaultdict()
        for account in accounts:
            name = account[0]
            emails = account[1:]
            for email in emails:
                email_to_name[email] = name
                graph[emails[0]].add(email)
                graph[email].add(emails[0])
        # print(graph)
        visited = set()
        res = []

        def bfs(e):
            ans = []
            stack = deque()
            stack.appendleft(e)
            while stack:
                tmp = stack.pop()
                ans.append(tmp)
                for t in graph[tmp]:

                    if t not in visited:
                        visited.add(t)
                        stack.appendleft(t)
            return ans

        for e in graph:
            # print(e)
            if e not in visited:
                visited.add(e)
                ans = bfs(e)
                res.append([email_to_name[e]] + sorted(ans))
        return res
# dfs

    def accountsMerge(self, accounts):
        from collections import defaultdict, deque
        graph = defaultdict(set)
        email_to_name = defaultdict()
        for account in accounts:
            name = account[0]
            emails = account[1:]
            for email in emails:
                email_to_name[email] = name
                graph[emails[0]].add(email)
                graph[email].add(emails[0])
        # print(graph)
        visited = set()
        res = []
        def dfs(e):
            new_list.append(e)
            for t in graph[e]:
                if t not in visited:
                    visited.add(t)
                    dfs(t)
        for e in graph:
            if e not in visited:
                visited.add(e)
                new_list = []
                dfs(e)
                res.append([email_to_name[e]] + sorted(new_list))
        return res
# 集合

    def accountsMerge(self, accounts):
        from collections import defaultdict
        if not accounts:
            return
        lookup = defaultdict(list)
        res = []
        for account in accounts:
            name = account[0]
            email = set(account[1:])

            lookup[name].append(email)
            for e in lookup[name][:-1]:
                if e & email:
                    lookup[name].remove(e)
                    lookup[name][-1].update(e)
        for key, val in lookup.items():

            for tmp in val:
                res.append([key] + list(sorted(tmp)))
        return res
