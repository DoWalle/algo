方法一：单向bfs

```python
class Solution(object):

    def ladderLength(self, beginWord, endWord, wordList):

        # 简单来说就是求图的两点最短路径，每个单词是一个点，只有相差一个字符的点之间才有路径，路径权值全部为1

        wordList = set(wordList)

        queue = [(beginWord, 1)] # 如果想早得到深度，得写一起

        if endWord not in wordList : return 0

        while queue:

            node, depth = queue.pop(0)

            if node == endWord:

                return depth

            for i in range(len(node)):

                for chr_num in range(97, 123):

                    word = node[:i] + chr(chr_num) + node[i+1:]

                    if word in wordList:

                        queue.append((word, depth+1))

                        wordList.remove(word)

        return 0
```
方法二：双向BFS

起点，结果已知可用双向bfs

1、参数定义

st：wordList对应的set集合，方便O(1)时间复杂度查找

m：每个单词长度

step：接龙单词个数

lqueue,rqueue：左右队列

lvisited,rvisited：左右集合，记录访问过的点

2、思路

和单向BFS不同的是，分别从beginWord和endWord开始做BFS，并分别将满足条件的单词加入到lqueue、lvisited和rqueue、rvisited。

以层为单位递增step

每次对元素少的队列进行BFS，如果访问到的单词在另外一边已被访问过，说明接龙成功，返回step

3、复杂度分析

时间复杂度：O(MN)，M为单词长度，N为wordList的长度

空间复杂度：O(N)

每次走最短边 88 ms 15.6 MB

```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        wordList = set(wordList)
        if endWord not in wordList:
            return 0

        size = len(beginWord)
        l_visited = {beginWord}
        r_visited = {endWord}
        l_queue = [beginWord]
        r_queue = [endWord]
        depth = 1
        while l_queue and r_queue:
            if len(l_queue) > len(r_queue):
                # 每次都走短的一侧，能走最小的面积
                l_queue, r_queue = r_queue, l_queue
                l_visited, r_visited = r_visited, l_visited
            for i in range(len(l_queue)): # 每层开始遍历
                cur_node = l_queue.pop(0)
                if cur_node in r_visited: # 如果当前节点在另一侧走过,返回
                    return depth
                for j in range(size):
                    for k in range(97, 123):
                        tmp = cur_node[:j] + chr(k) + cur_node[j+1:]
                        if tmp in wordList and tmp not in l_visited:
                            l_queue.append(tmp)
                            l_visited.add(tmp)
            depth += 1

        return 0
```

每次各换一边走，276 ms	15.5 MB

```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        wordList = set(wordList)
        if endWord not in wordList:
            return 0

        size = len(beginWord)
        l_visited = {beginWord}
        r_visited = {endWord}
        l_queue = [beginWord]
        r_queue = [endWord]
        depth = 1
        while l_queue and r_queue:
            # if len(l_queue) > len(r_queue):
            #     # 每次都走短的一侧，能走最小的面积
            #     l_queue, r_queue = r_queue, l_queue
            #     l_visited, r_visited = r_visited, l_visited
            for i in range(len(l_queue)): # 每层开始遍历
                cur_node = l_queue.pop(0)
                if cur_node in r_visited: # 如果当前节点在另一侧走过,返回
                    return depth
                for j in range(size):
                    for k in range(97, 123):
                        tmp = cur_node[:j] + chr(k) + cur_node[j+1:]
                        if tmp in wordList and tmp not in l_visited:
                            l_queue.append(tmp)
                            l_visited.add(tmp)
            depth += 1
            l_queue, r_queue = r_queue, l_queue
            l_visited, r_visited = r_visited, l_visited

        return 0
```


