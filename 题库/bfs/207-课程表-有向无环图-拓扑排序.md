理论：https://oi-wiki.org/graph/topo/#kahn

题解：https://leetcode-cn.com/problems/course-schedule/solution/ke-cheng-biao-by-leetcode-solution/

bfs: 32 ms 15.6 MB
```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        edges = collections.defaultdict(list)
        in_degrees = [0 for _ in range(numCourses)] # 每个点的入度
        topo = [] # 拓扑排序

        # 邻接表
        for v, u in prerequisites:
            edges[u].append(v)
            in_degrees[v] += 1

        queue = collections.deque([u for u in range(numCourses) if in_degrees[u] == 0])
        visited = 0
        while queue:
            u = queue.popleft()
            topo.append(u)
            visited += 1
            for v in edges[u]:
                in_degrees[v] -= 1
                if in_degrees[v] == 0:
                    # 必须从没有依赖的节点往下走
                    queue.append(v)

        print(topo)
        return visited == numCourses
```

dfs: 48 ms 18.3 MB
```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        edges = colledctions.defaultdict(list) # 邻接表
        visited = [0] * numCourses
        topo = list() # 逆序为拓扑排序
        self.valid = True # 是否为有向无环图

        for info in prerequisites:
            edges[info[1]].append(info[0])
        
        def dfs(u: int):
            visited[u] = 1
            for v in edges[u]:
                if visited[v] == 0:
                    dfs(v)

                    if not self.valid:
                        # 退出
                        return
                elif visited[v] == 1:
                    # 经过层层查找，还有为1的，也就是里面还有环，就退出
                    self.valid = False
                    return
                    
            visited[u] = 2
            topo.append(u)
        
        for i in range(numCourses):
            if self.valid and not visited[i]:
                dfs(i)
        print(topo[::-1])
        return self.valid
```
