https://leetcode-cn.com/problems/freedom-trail/solution/shou-hua-tu-jie-di-gui-ji-yi-hua-di-gui-514-zi-you/

**记忆化适用于dfs**，因为bfs无法得知未来的事，用起来比较麻烦

```python
class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
        # dfs记忆化
        # 把外围的字母想象成不动的，12点想象为指针在转动
        ring_sz = len(ring)
        key_sz = len(key)
        position = collections.defaultdict(set)
        for i, v in enumerate(ring):
            position[v].add(i)
        memo = [[-1 for _ in range(key_sz)] for _ in range(ring_sz)]
        
        def dfs(cur, index):
            # 递归函数表示，当前12点指向ring[cur], 要走到key[index]的最短距离
            # cur 为当前12点指向的数字在ring的位置 
            # index 为key中想要找到字母的位置
            # print(cur, index) 在这里打印可以找到重复跑的, 就可以用记忆化dfs
            if index == key_sz:
                # 此时越界，所有的key都已经找全
                return 0
            if memo[cur][index] != -1:
                return memo[cur][index]
                
            res = float("inf")
            for p in position[key[index]]:
                left = abs(p - cur) + 1 + dfs(p, index+1)
                right = ring_sz - abs(p - cur) + 1 + dfs(p, index+1)
                res = min(res, left, right)

            memo[cur][index] = res
            return res

        return dfs(0, 0)     
```

