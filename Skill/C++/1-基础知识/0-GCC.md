# GCC

**GCC 是 GNU 编译器集合的意思, 对于用户能用的常用命令, 有「gcc」和「g++」**

无论是 gcc 还是 g++, 他们的定位都是 driver.

driver 负责调用编译器(狭义), 把源码编译到汇编代码. 比如 C 语言的编译器(狭义)是 `cc1`, 而 C++ 语言的编译器(狭义)是 `cc1plus`.

driver 再调用 as, 把汇编代码变成二进制代码. 最后调用 ld, 负责把二进制代码拼在一起.

## 一、gcc 与 g++ 异同

gcc 和 g++ 的区别无非就是调用的编译器不同, 并且传递给链接器的参数不同.

具体而言

**g++** 会把 `.c` 文件当做是 C++ 语言 (在 `.c` 文件前后分别加上 `-xc++` 和 `-xnone`, 强行变成 C++), 从而调用 `cc1plus`进行编译.

**g++** 遇到 `.cpp` 文件也会当做是 C++, 调用 `cc1plus` 进行编译. 

**g++** 还会默认告诉链接器, 让它链接上 C++ 标准库.



**gcc** 会把 `.c` 文件当做是 C 语言. 从而调用 `cc1` 进行编译.

**gcc** 遇到 `.cpp` 文件, 会处理成 C++ 语言. 调用 `cc1plus` 进行编译. 

**gcc** 默认不会链接上 C++ 标准库.

## 二、g++ 使用

```shell
g++ main.cpp -o main -std=c++11
```

-o 指定输出二进制名

-std 指定 c++ 标准，如 c++11  c++17

**查看 g++ 版本**

```c++
#include <iostream>
using namespace std;

int main() {
    cout << __cplusplus << endl;
    // 输出如：199711、201103、201703
    return 0;
}
```

## 三、从源码到可执行文件

![从源码到可执行文件](../doc/从源码到可执行文件.png)

1. 预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件（.i文件）

2. 编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件(.s文件)

3. 汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件 (.o或.obj文件)

4. 链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件(.out或.exe文件)

### 1、预处理阶段

在预处理阶段中，hello.cpp(源程序文本)会由**预处理器(cpp)** 修改，即让 hello.cpp 变为 hello.i 文件。

g++命令行如下：

```c++
g++ hello.cpp -E > hello.i
```

其中-E选项是只运行C预处理器的选项；>是重定向一个输出文件 test.i

**预处理器(cpp) 的作用**：提供了预处理命令

**预处理(cpp)的过程：**主要处理那些源代码文件中只能够以“#”开始的预处理指令。具体指令如下：

主要规则如下：

- 对所有的“#define”进行宏展开；“#undef” 取消宏定义
- 处理所有的条件编译指令，比如“#if”,“#ifdef”，“#elif”，“#else”,“#endif” 
- 处理“#include”指令，这个过程是递归的，也就是说被包含的文件可能还包含其他文件 
- 删除所有的注释“//”和“/**/” 
- 添加行号和文件标识 
- 保留所有的“#pragma”编译器指令 经过预处理后的 .i 文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中。

结束当前阶段后，如果用文本编辑器打开test.i文件，发现我们的程序前面多了很多东西。该阶段编译原理就是将头文件**#include** 库中的内容插入程序文本当中，得到了test.i文件。

### 2、编译阶段

当我们得到了 hello.i 文件后,就可以进入编译阶段了，

在编译阶段，接下来需要的是用「编译器(ccl)」将文本文件 hello.i 翻译成文本文件 hello.s，这是一个汇编程序.

**编译的过程就是将预处理完的文件进行一系列词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件(.s文件)**

使用-S编译选项即可以得到.s程序

```shell
g++ hello.i -S
```

或由 hello.cpp 直接得到汇编文件

```shell
g++ hello.cpp -S
```

#### 1）词法分析

词法分析主要使用词法分析器（也叫**扫描器**），将源代码的字符序列分割成一系列的**符号**（Token）

词法分析产生的记号一般可以分为：关键字，标识符，字面量（包括数字和字符串等）和特殊符号（加号减号等）。在识别记号的同时，扫描器也完成其他工作，比如讲标识符存放到符号表，讲数字字符串常量存放到文字表，以备后面的步骤使用。

#### 2）语法分析

接下来**语法分析器**将对由扫描器产生的记号进行语法分析，从而产生语法树。整个分析过程采用了**上下文无关语法**的分析手段。

#### 3）语义分析

这个阶段由**语义分析器**来完成。语法分析仅仅完成了对表达式的语法层面的分析，他并不了解这个语句是不是真的有意义。比如两个指针相乘是没有意义的，但是在语法上是合法的。

编译器可以分析的语义是静态语义，即在编译器就可以确定的语义；与之对应的是动态语义，即在运行期才可以确定的语义。

静态语义通常包括声明和类型的匹配，类型的转换。比如一个浮点型表达式赋值给整形表达式的时候，语义分析会完成浮点型到整形的转换。动态语义使之运行期出现的语义相关问题，比如除数是0的时候会报运行期语义错误。

#### 4）源代码优化

现代编译器有很多层的优化，往往在源代码级别会有一个优化过程。**源代码优化器**会在源码级别进行优化，比如一行代码：

```
array[index] = (index + 4) * (2 + 6);
```

在这行代码中，(2+6)这个表达式就可以被优化掉，因为他的值在编译器就可以确定。

在进行了语法分析和语义分析阶段的工作之后，有的编译程序将源程序变成一种内部表示形式，这种内部表示形式叫做中间语言或中间表示或中间代码。所谓“中间代码”是一种结构简单、含义明确的记号系统，这种记号系统复杂性介于源程序语言和机器语言之间，容易将它翻译成目标代码。

中间代码使得编译器可以分为前端和后端，前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。这样对于一些跨平台的编程语言，他们可以针对不同平台使用同一个前端和针对不同平台的数个后端。

### 3、汇编阶段

得到了汇编程序后，**汇编器（as）** 会将 hello.s 文件进行汇编，将复杂晦涩难懂的汇编指令变为机器语言指令，每一个汇编语句几乎都对应一条机器指令，并把这些指令打包成一种 **可重定位目标程序**并将结果保存在hello.o(.o或.obj文件)中

使用 -c 编译选项，该选项只编译生成目标文件，不链接，链接动作是在链接阶段完成的。

```shell
g++ -c hello.s -o hello.o
```

对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。目标文件由段组成，通常一个**目标文件中至少有两个段**：

1. **代码段**：该段中所包含的**主要是程序的指令**。该段一般是可读和可执行的，但一般却不可写。
2. **数据段**：主要存放程序中要用到的各种**全局变量或静态的数据**。一般数据段都是可读，可写，可执行的。

UNIX环境下主要有**三种类型的目标文件**：

1. 可重定位文件：其中包含有适合于其它目标文件链接来创建一个可执行的或者共享的目标文件的代码和数据。
2. 共享的目标文件：这种文件存放了适合于在两种上下文里链接的代码和数据。第一种事链接程序可把它与其它可重定位文件及共享的目标文件一起处理来创建另一个目标文件；第二种是动态链接程序将它与另一个可执行文件及其它的共享目标文件结合到一起，创建一个进程映象。
3. 可执行文件：它包含了一个可以被操作系统创建一个进程来执行之的文件。

汇编程序生成的实际上是第一种类型的目标文件。对于后两种还需要其他的一些处理方能得到，这个就是链接程序的工作了。

### 4、链接阶段

当一个程序调用了标准库中的函数，例如printf、cout等，这个函数已经存在于一个已经单独预编译好了的.o文件中，而这个文件必须以某种方式合并到我们的 hello.o 当中，得到可执行的 hello 文件。

**链接的过程主要包括了地址和空间分配(Address and Storage Allocation)、符号决议(Symbol Resolution)和重定位(Relocation)**。

链接就是把每个源代码独立的编译，然后按照它们的要求将它们组装起来，链接主要解决的是源代码之间的相互依赖问题，链接的过程包括地址和空间的分配，符号决议，和重定位等这些步骤。最基本的静态链接如图所示：

g++命令行如下：

```shell
# 动态链接
g++ hello.o -o hello

# 静态链接
g++ hello.o -static -o hello
```

2种都可生成可执行文件，前者文件只包含文件名，运行时再链接相关函数，后者编译时便链接相关函数，前者体积小，运行时没后者快，后者体积大。

这样得到一个可执行目标文件，就可以被加载到内存当中，即可被执行。

每个目标文件除了拥有自己的数据和二进制代码外，还拥有三个表，未解决符号表，地址重定向表，导出符号表。根据开发人员指定的同库函数的链接方式的不同，链接处理可分为两种：

#### 1）静态链接/库

在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中，因此对应的链接方式称为静态链接。

**静态库可以简单看成是一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。**

**静态库的缺点在于：浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。**

#### 2）动态链接/库

**动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题**。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。
