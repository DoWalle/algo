# 指针

**指针**是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：

```c++
type *var-name;
```

在这里，**type** 是指针的基类型，它必须是一个有效的 C++ 数据类型，**var-name** 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：

```c++
int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;    /* 一个字符型的指针 */
```

所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的**十六进制数**。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。

| 概念                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [C++ Null 指针](https://www.runoob.com/cplusplus/cpp-null-pointers.html) | C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 |
| [C++ 指针的算术运算](https://www.runoob.com/cplusplus/cpp-pointer-arithmetic.html) | 可以对指针进行四种算术运算：++、--、+、-                     |
| [C++ 指针 vs 数组](https://www.runoob.com/cplusplus/cpp-pointers-vs-arrays.html) | 指针和数组之间有着密切的关系。                               |
| [C++ 指针数组](https://www.runoob.com/cplusplus/cpp-array-of-pointers.html) | 可以定义用来存储指针的数组。                                 |
| [C++ 指向指针的指针](https://www.runoob.com/cplusplus/cpp-pointer-to-pointer.html) | C++ 允许指向指针的指针。                                     |
| [C++ 传递指针给函数](https://www.runoob.com/cplusplus/cpp-passing-pointers-to-functions.html) | 通过引用或地址传递参数，使传递的参数在调用函数中被改变。     |
| [C++ 从函数返回指针](https://www.runoob.com/cplusplus/cpp-return-pointer-from-functions.html) | C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。     |

## 一、使用指针

- 定义一个指针变量
- 把变量地址赋值给指针
- 访问指针变量中可用地址的值

 *** 来返回位于操作数所指定地址的变量的值**

**& 取地址符，获取变量在内存中的地址**

```c++
int  var = 20;   // 实际变量的声明
int  *ip;        // 指针变量的声明

ip = &var;       // 在指针变量中存储 var 的地址

cout << var << endl; // 20

// 输出在指针变量中存储的地址
cout << ip << endl; // 0x7fffffffdf6c

// 访问指针中地址的值
cout << *ip << endl; // 20
```

## 二、空指针 NUll、nullptr

在C++中，NULL实际上是0，因此不能把void*类型的指针隐式转换成其他类型的指针。

用 NULL 代替0表示空指针在函数重载时会出现问题。

为解决NULL代指空指针存在的二义性问题，在C++11版本(2011年发布)中特意引入了 **nullptr** 这一新的关键字来代指空指针

下面的例子中可以看到，使用 **nullptr** 作为实参，确实选择了正确的以void*作为形参的函数版本。

```c++
#include <iostream>
using namespace std;

void func(int i) {
    cout << "func(int i) " << i << endl;
}

void func(void* t) {
    cout << "func(void* t) " << t << endl;
}

int main() {
    // func(NULL);     // 报错
    func(nullptr);  // func(void* t) 0x0
    return 0;
}
```

**以后都用nullptr替代NULL吧，而NULL就当做0使用**

在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 nullptr 值是一个良好的编程习惯。赋为 nullptr 值的指针被称为**空指针**。

nullptr 是 0x0

NULL 指针是一个定义在标准库中的值为零的常量。

```c++
int *ptr = nullptr;
// int *ptr = NULL;
cout << ptr << endl;  // 0x0
```

需检查一个空指针，可以使用 if 语句:

```
if(ptr)     /* 如果 ptr 非空，则完成 */
if(!ptr)    /* 如果 ptr 为空，则完成 */
```

## 三、指针的算术运算

指针是一个用**十六进制数值**表示的地址。

- 可对指针进行四种算术运算：++、--、+、-
- 可用关系运算符进行比较： ==、<、 >

### 1、递增一个指针

我们喜欢在程序中**使用指针代替数组，因为变量指针可以递增，而数组不能递增**

因为数组是一个常量指针，指向数组的第一个元素。

```c++
#include <iostream>

using namespace std;
const int MAX = 3;

int main()
{
    int var[MAX] = {10, 100, 200};
    int *ptr;

    ptr = var; // 指针指向数组的第一个元素地址上
    for (int i = 0; i < MAX; i++)
    {
        cout << "val: " << *ptr << " ";
        cout << "addr: " << ptr << endl;
        ptr++; // 移动到下一个位置
    }
    return 0;
}

// val: 10 addr: 0x7fffffffdf6c
// val: 100 addr: 0x7fffffffdf70
// val: 200 addr: 0x7fffffffdf74
```

### 2、递减一个指针

```c++
#include <iostream>

using namespace std;
const int MAX = 3;

int main()
{
    int var[MAX] = {10, 100, 200};
    int *ptr;

    ptr = &var[MAX-1]; // 指针指向数组的最后一个元素地址上
    for (int i = 0; i < MAX; i++)
    {
        cout << "val: " << *ptr << " ";
        cout << "addr: " << ptr << endl;
        ptr--; // 移动到下一个位置
    }
    return 0;
}
// val: 200 addr: 0x7fffffffdf74
// val: 100 addr: 0x7fffffffdf70
// val: 10 addr: 0x7fffffffdf6c
```

### 3、指针的比较

```c++
#include <iostream>

using namespace std;
const int MAX = 3;

int main()
{
    int var[MAX] = {10, 100, 200};
    int *ptr;

    ptr = var; // 指针指向数组的第一个元素地址上
    while (ptr <= &var[MAX - 1])
    {
        cout << "val: " << *ptr << " ";
        cout << "addr: " << ptr << endl;
        ptr++; // 移动到下一个位置
    }

    return 0;
}
// val: 10 addr: 0x7fffffffdf6c
// val: 100 addr: 0x7fffffffdf70
// val: 200 addr: 0x7fffffffdf74
```

## 四、指针数组

数组存储指向 int 或 char 或其他数据类型的指针。下面是一个指向整数的指针数组的声明，每个元素都是一个指向 int 值的指针：

```c++
int *ptr[MAX];
```

```c++
#include <iostream>

using namespace std;
const int MAX = 3;

int main()
{
    int var[MAX] = {10, 100, 200};
    int *ptr[MAX];

    for (int i = 0; i < MAX; i++)
    {
        ptr[i] = &var[i]; // 赋值为整数的地址
    }

    for (int i = 0; i < MAX; i++)
    {
        cout << "val: " << *ptr[i] << " ";
        cout << "addr: " << ptr[i] << endl;
    }
    return 0;
}
// val: 10 addr: 0x7fffffffdf54
// val: 100 addr: 0x7fffffffdf58
// val: 200 addr: 0x7fffffffdf5c

```

```c++
const char *names[3] = {
    "Zara Ali",
    "Hina Ali",
    "Nuha Ali"
};

for (int i = 0; i < 3; i++)
{
    cout << "val: " << names[i] << " ";
    cout << "addr: " << &names[i] << endl;
}
// val: Zara Ali addr: 0x7fffffffdf60
// val: Hina Ali addr: 0x7fffffffdf68
// val: Nuha Ali addr: 0x7fffffffdf70
```

## 五、指向指针的指针

指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。

指针的指针就是将指针的地址存放在另一个指针里面。

一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号

```
int **var;
```

当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符，如下面实例所示：

```c++
#include <iostream>

using namespace std;

int main()
{
    int num = 123;
    int *ptr;
    int **pptr;

    ptr = &num;
    pptr = &ptr;

    cout << "num " << "val: " << num << " " << "addr: " << &num << endl;
    cout << "ptr" << " val: " << ptr << " " << "addr: " << &ptr << endl;
    cout << "pptr" << " val: " << pptr << " " << "addr: " << &pptr << endl;

    cout << *ptr << endl;
    cout << **pptr << endl;

    return 0;
}
// num val: 123 addr: 0x7fffffffdf64
// ptr val: 0x7fffffffdf64 addr: 0x7fffffffdf68
// pptr val: 0x7fffffffdf68 addr: 0x7fffffffdf70
// 123
// 123
```

