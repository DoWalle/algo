# 运行时多态与虚函数

来源：[http://c.biancheng.net/cplus/polymorphism/](http://c.biancheng.net/cplus/polymorphism/)

面向对象程序设计语言有封装、继承和多态三种机制，这三种机制能够有效提高程序的可读性、可扩充性和可重用性。

「多态 polymorphism」指的是同一名字的事物可以完成不同的功能。**多态可以分为编译时的多态和运行时的多态**。

- 前者主要是指函数的重载（包括运算符的重载）、对重载函数的调用，在编译时就能根据实参确定应该调用哪个函数，因此叫编译时的多态；
- 而后者则和继承、虚函数等概念有关，是本章要讲述的内容。本教程后面提及的多态都是指运行时的多态。

## 一、多态和虚函数入门

在《[C++将派生类赋值给基类（向上转型）](./2-继承与派生.md)》一节中讲到，基类的指针也可以指向派生类对象，请看下面的例子

```c++
#include <iostream>
using namespace std;

class People {  // 基类People
public:
    People(char *name, int age);
    void display();

protected:
    char *m_name;
    int m_age;
};
People::People(char *name, int age) : m_name(name), m_age(age) {}
void People::display() {
    cout << m_name << " age:" << m_age << endl;
}

class Teacher : public People {  // 派生类Teacher
public:
    Teacher(char *name, int age, int salary);
    void display();

private:
    int m_salary;
};
Teacher::Teacher(char *name, int age, int salary) : People(name, age), m_salary(salary) {}
void Teacher::display() {
    cout << m_name << " age:" << m_age << " salary:" << m_salary << endl;
}

int main() {
    People *p = new People("WiWi", 23);
    p->display();  // WiWi age:23

    p = new Teacher("DoDo", 45, 8200);
    p->display();  // DoDo age:45
    return 0;
}
```

我们直观上认为，如果指针指向了派生类对象，那么就应该使用派生类的成员变量和成员函数，这符合人们的思维习惯。

但是本例的运行结果却告诉我们，当基类指针 p 指向派生类 Teacher 的对象时，**虽然使用了 Teacher 的成员变量，但是却没有使用它的成员函数**，导致输出结果不伦不类（赵宏佳本来是一名老师，输出结果却显示人家是个无业游民），不符合我们的预期。

换句话说，**通过基类指针只能访问派生类的「成员变量」，但是不能访问派生类的「成员函数」**。

### 使用「指针+虚函数」实现多态

为了消除这种尴尬，**让基类指针能够访问派生类的成员函数**，C++增加了**虚函数（Virtual Function）**。使用虚函数非常简单，只需要在函数声明前面增加 virtual 关键字。

```c++
#include <iostream>
using namespace std;

class People {  // 基类People
public:
    People(char *name, int age);
    virtual void display();  // 声明为虚函数
protected:
    char *m_name;
    int m_age;
};
People::People(char *name, int age) : m_name(name), m_age(age) {}
void People::display() {
    cout << m_name << " age:" << m_age << endl;
}

class Teacher : public People {  // 派生类Teacher
public:
    Teacher(char *name, int age, int salary);
    virtual void display();  // 声明为虚函数
private:
    int m_salary;
};
Teacher::Teacher(char *name, int age, int salary) : People(name, age), m_salary(salary) {}
void Teacher::display() {
    cout << m_name << " age:" << m_age << " salary:" << m_salary << endl;
}
int main() {
    People *p = new People("WiWi", 23);
    p->display();  // WiWi age:23

    p = new Teacher("DoDo", 45, 8200);
    p->display();  // DoDo age:45 salary:8200
    return 0;
}
```

有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。

换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为**多态（Polymorphism）**

上面的代码中，同样是`p->display();`这条语句，当 p 指向不同的对象时，它执行的操作是不一样的。同一条语句可以执行不同的操作，看起来有不同表现方式，这就是多态

多态是面向对象编程的主要特征之一，**C++中虚函数的唯一用处就是构成多态**。

C++提供多态的目的是：**可以通过「基类指针」对「所有派生类」（包括直接派生和间接派生）的「成员变量」和「成员函数」进行「全方位」的访问，尤其是「成员函数」。如果没有多态，我们只能访问成员变量**。

### 使用「引用+虚函数」实现多态

```c++
#include <iostream>
using namespace std;

class People {  // 基类People
public:
    People(char *name, int age);
    virtual void display();  // 声明为虚函数
protected:
    char *m_name;
    int m_age;
};
People::People(char *name, int age) : m_name(name), m_age(age) {}
void People::display() {
    cout << m_name << " age:" << m_age << endl;
}

class Teacher : public People {  // 派生类Teacher
public:
    Teacher(char *name, int age, int salary);
    virtual void display();  // 声明为虚函数
private:
    int m_salary;
};
Teacher::Teacher(char *name, int age, int salary) : People(name, age), m_salary(salary) {}
void Teacher::display() {
    cout << m_name << " age:" << m_age << " salary:" << m_salary << endl;
}

int main() {
    People p("WiWi", 23);
    Teacher t("DoDo", 45, 8200);

    People &rp = p;
    People &rt = t;

    rp.display();  // WiWi age:23
    rt.display();  // DoDo age:45 salary:8200
    return 0;
}
```

由于引用类似于常量，只能在定义的同时初始化，并且以后也要从一而终，不能再引用其他数据，所以本例中必须要定义两个引用变量，一个用来引用基类对象，一个用来引用派生类对象。从运行结果可以看出，当基类的引用指代基类对象时，调用的是基类的成员，而指代派生类对象时，调用的是派生类的成员。

不过**引用不像指针灵活，指针可以随时改变指向，而引用只能指代固定的对象，在多态性方面缺乏表现力**，所以以后我们再谈及多态时一般是说指针。

### 多态的用途

通过上面的例子读者可能还未发现多态的用途，不过确实也是，多态在小项目中鲜有有用武之地。

接下来的例子中，我们假设你正在玩一款军事游戏，敌人突然发动了地面战争，于是你命令陆军、空军及其所有现役装备进入作战状态。具体的代码如下所示：

```c++
#include <iostream>
#include <vector>
using namespace std;

class Troops {  // 军队
public:
    virtual void fight() { cout << "Strike back!" << endl; }
};

class Army : public Troops {  // 陆军
public:
    void fight() { cout << "--Army is fighting!" << endl; }
};

class _99A : public Army {  // 99A主战坦克
public:
    void fight() { cout << "----99A(Tank) is fighting!" << endl; }
};

class WZ_10 : public Army {  // 武直10武装直升机
public:
    void fight() { cout << "----WZ-10(Helicopter) is fighting!" << endl; }
};

class CJ_10 : public Army {  // 长剑10巡航导弹
public:
    void fight() { cout << "----CJ-10(Missile) is fighting!" << endl; }
};

class AirForce : public Troops {  // 空军
public:
    void fight() { cout << "--AirForce is fighting!" << endl; }
};

class J_20 : public AirForce {  // J-20隐形歼击机
public:
    void fight() { cout << "----J-20(Fighter Plane) is fighting!" << endl; }
};

class CH_5 : public AirForce {  // CH5无人机
public:
    void fight() { cout << "----CH-5(UAV) is fighting!" << endl; }
};

class H_6K : public AirForce {  // 轰6K轰炸机
public:
    void fight() { cout << "----H-6K(Bomber) is fighting!" << endl; }
};

void runFight(Troops *p) {
    p->fight();
}

int main() {
    vector<Troops *> TroopsList;
    TroopsList.push_back(new Troops);
    // 陆军
    TroopsList.push_back(new Army);
    TroopsList.push_back(new _99A);
    TroopsList.push_back(new WZ_10);
    TroopsList.push_back(new CJ_10);

    // 空军
    TroopsList.push_back(new AirForce);
    TroopsList.push_back(new J_20);
    TroopsList.push_back(new CH_5);
    TroopsList.push_back(new H_6K);

    for (auto p : TroopsList) {
        runFight(p);
    }
    return 0;
}

// Strike back!
// --Army is fighting!
// ----99A(Tank) is fighting!
// ----WZ-10(Helicopter) is fighting!
// ----CJ-10(Missile) is fighting!
// --AirForce is fighting!
// ----J-20(Fighter Plane) is fighting!
// ----CH-5(UAV) is fighting!
// ----H-6K(Bomber) is fighting!
```

这个例子中的派生类比较多，如果不使用多态，那么就需要定义多个指针变量，很容易造成混乱；而有了多态，只需要一个指针变量 p 就可以调用所有派生类的虚函数。

从这个例子中也可以发现，对于具有复杂继承关系的大中型程序，多态可以增加其灵活性，让代码更具有表现力。

## 二、虚函数注意事项以及构成多态的条件

