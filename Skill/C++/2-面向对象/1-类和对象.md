# 类和对象

## 一、基本知识

类是创建对象的模板，一个类可以创建多个对象，每个对象都是类类型的一个变量；

创建对象的过程也叫「类的实例化」；

每个对象都是类的一个具体「实例」，拥有类的「成员变量」和「成员函数」；

- 类的成员变量，也称为类的属性（Property）
- 类的成员函数，也称为类的方法（Method）

```c++
#include <iostream>
using namespace std;

class Box {
public:
    // 成员变量
    int length;
    int width;
    int height;
    // 成员函数声明
    int get(void);
    void set(int l, int w, int h);
};
// 成员函数定义
int Box::get(void) {
    return length * width * height;
}
void Box::set(int l, int w, int h) {
    length = l;
    width = w;
    height = h;
}

int main() {
    Box box1;  // 声明 box1，类型为 Box
    Box box2;  // 声明 box2，类型为 Box

    box1.height = 1;
    box1.length = 2;
    box1.width = 3;

    box2.set(2, 3, 4);

    cout << box1.get() << endl;  // 6
    cout << box2.get() << endl;  // 24
    return 0;
}
```

## 二、使用对象指针

普通创建的对象 box 在「栈」上分配内存，需要使用 `&` 获取它的地址

```c++
Box box;
Box *ptr = &box;
```

也可用 `new` 在「堆」上创建对象

```c++
Box *ptr = new Box;
```

在栈上创建出来的对象都有一个名字，比如 box，使用指针指向它不是必须的。但是通过 new 创建出来的对象就不一样了，它在堆上分配内存，没有名字，只能得到一个指向它的指针，所以必须使用一个指针变量来接收这个指针，否则以后再也无法找到这个对象了，更没有办法使用它。也就是说，**使用 new 在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。**

**栈内存是程序自动管理的**，不能使用 delete 删除在栈上创建的对象；堆内存由程序员管理，对象使用完毕后可以通过 delete 删除。在实际开发中，new 和 delete 往往成对出现，以保证及时删除不再使用的对象，防止无用内存堆积。

```c++
#include <iostream>

using namespace std;

class Box {
public:
    // 成员变量
    int length;
    int width;
    int height;
    // 成员函数声明
    int get(void);
    void set(int l, int w, int h);
};
// 成员函数定义
int Box::get(void) {
    return length * width * height;
}
void Box::set(int l, int w, int h) {
    length = l;
    width = w;
    height = h;
}

int main() {
    Box box1;
    Box *ptr1 = &box1;
    ptr1->set(1, 2, 3);

    Box *ptr2 = new Box;
    ptr2->length = 2;
    ptr2->width = 3;
    ptr2->height = 4;

    cout << ptr1->get() << endl;  // 6
    cout << ptr2->get() << endl;  // 24
    return 0;
}
```

有了对象指针后，通过箭头`->`来访问对象的成员变量和成员函数

## 三、成员变量和成员函数

类的成员变量和普通变量一样，也有数据类型和名称，占用固定长度的内存。但是，在定义类的时候不能对成员变量赋值（可以给个初始值），因为类只是一种数据类型或者说是一种模板，本身不占用内存空间，而变量的值则需要内存来存储。

类的成员函数也和普通函数一样，都有返回值和参数列表，它与一般函数的区别是：成员函数是一个类的成员，出现在类体中，它的作用范围由类来决定；而普通函数是独立的，作用范围是全局的，或位于某个命名空间内。

在类体中和类体外定义成员函数是有区别的：**在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会**

所以一般来说，都在类体外定义。在函数名前面加上类名予以限定，`::`被称为域解析符（也称作用域运算符或作用域限定符），用来连接类名和函数名，指明当前函数属于哪个类。

```c++
#include <iostream>

using namespace std;

class Box {
public:
    int length = 1;
    int width = 2;
    int height = 3;

    void show(void) {
        cout << length * width * height << endl;
    }
    void set(int l, int w, int h);
};
void Box::set(int l, int w, int h) {
    length = l;
    width = w;
    height = h;
}

int main() {
    Box box;
    box.show();  // 6

    box.set(2, 3, 4);
    box.show();  // 24
    return 0;
}
```

## 四、访问权限

通过「成员访问限定符」来控制成员变量和成员函数的访问权限：

- public 公有的
- protected 受保护的
- private私有的

在类的内部，无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。

在类的外部，只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。

但在派生类内部，protected 属性的成员可以访问。

```c++
#include <iostream>
using namespace std;
//类的声明
class Student {
private:  //私有的
    string m_name;
    int m_age;

public:  //共有的
    void setname(string name);
    void setage(int age);
    void show();
};
//成员函数的定义
void Student::setname(string name) {
    m_name = name;
}
void Student::setage(int age) {
    m_age = age;
}
void Student::show() {
    cout << m_name << " " << m_age << endl;
}

int main() {
    //在栈上创建对象
    Student stu;
    stu.setname("dodo");
    stu.setage(10);
    stu.show();  // dodo 10
    //在堆上创建对象
    Student *pstu = new Student;
    pstu->setname("keke");
    pstu->setage(20);
    pstu->show();  // keke 20
    return 0;
}

```



## 五、封装

根据C++软件设计规范，实际项目开发中的成员变量以及只在类内部使用的成员函数（只被成员函数调用的成员函数）都建议声明为 private，而只将允许通过对象调用的成员函数声明为 public。

对于不可访问的成员变量，可以额外添加两个 public 属性的成员函数，一个用来设置（set）成员变量的值，一个用来获取（get）成员变量的值

**这种将成员变量声明为 private、将部分成员函数声明为 public 的做法体现了类的封装性。所谓封装，是指尽量隐藏类的内部实现，只向用户提供有用的成员函数。**

