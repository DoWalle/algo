# 类和对象

## 一、基本知识

类是创建对象的模板，一个类可以创建多个对象，每个对象都是类类型的一个变量；

创建对象的过程也叫「类的实例化」；

每个对象都是类的一个具体「实例」，拥有类的「成员变量」和「成员函数」；

- 类的成员变量，也称为类的属性（Property）
- 类的成员函数，也称为类的方法（Method）

```c++
#include <iostream>
using namespace std;

class Box {
public:
    // 成员变量
    int length;
    int width;
    int height;
    // 成员函数声明
    int get(void);
    void set(int l, int w, int h);
};
// 成员函数定义
int Box::get(void) {
    return length * width * height;
}
void Box::set(int l, int w, int h) {
    length = l;
    width = w;
    height = h;
}

int main() {
    Box box1;  // 声明 box1，类型为 Box
    Box box2;  // 声明 box2，类型为 Box

    box1.height = 1;
    box1.length = 2;
    box1.width = 3;

    box2.set(2, 3, 4);

    cout << box1.get() << endl;  // 6
    cout << box2.get() << endl;  // 24
    return 0;
}
```

## 二、使用对象指针

普通创建的对象 box 在「栈」上分配内存，需要使用 `&` 获取它的地址

```c++
Box box;
Box *ptr = &box;
```

也可用 `new` 在「堆」上创建对象

```c++
Box *ptr = new Box;
```

在栈上创建出来的对象都有一个名字，比如 box，使用指针指向它不是必须的。但是通过 new 创建出来的对象就不一样了，它在堆上分配内存，没有名字，只能得到一个指向它的指针，所以必须使用一个指针变量来接收这个指针，否则以后再也无法找到这个对象了，更没有办法使用它。也就是说，**使用 new 在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。**

**栈内存是程序自动管理的**，不能使用 delete 删除在栈上创建的对象；堆内存由程序员管理，对象使用完毕后可以通过 delete 删除。在实际开发中，new 和 delete 往往成对出现，以保证及时删除不再使用的对象，防止无用内存堆积。

```c++
#include <iostream>

using namespace std;

class Box {
public:
    // 成员变量
    int length;
    int width;
    int height;
    // 成员函数声明
    int get(void);
    void set(int l, int w, int h);
};
// 成员函数定义
int Box::get(void) {
    return length * width * height;
}
void Box::set(int l, int w, int h) {
    length = l;
    width = w;
    height = h;
}

int main() {
    Box box1;
    Box *ptr1 = &box1;
    ptr1->set(1, 2, 3);

    Box *ptr2 = new Box;
    ptr2->length = 2;
    ptr2->width = 3;
    ptr2->height = 4;

    cout << ptr1->get() << endl;  // 6
    cout << ptr2->get() << endl;  // 24
    return 0;
}
```

有了对象指针后，通过箭头`->`来访问对象的成员变量和成员函数

## 三、成员变量和成员函数

类的成员变量和普通变量一样，也有数据类型和名称，占用固定长度的内存。但是，在定义类的时候不能对成员变量赋值（可以给个初始值），因为类只是一种数据类型或者说是一种模板，本身不占用内存空间，而变量的值则需要内存来存储。

类的成员函数也和普通函数一样，都有返回值和参数列表，它与一般函数的区别是：成员函数是一个类的成员，出现在类体中，它的作用范围由类来决定；而普通函数是独立的，作用范围是全局的，或位于某个命名空间内。

在类体中和类体外定义成员函数是有区别的：**在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会**

所以一般来说，都在类体外定义。在函数名前面加上类名予以限定，`::`被称为域解析符（也称作用域运算符或作用域限定符），用来连接类名和函数名，指明当前函数属于哪个类。

```c++
#include <iostream>

using namespace std;

class Box {
public:
    int length = 1;
    int width = 2;
    int height = 3;

    void show(void) {
        cout << length * width * height << endl;
    }
    void set(int l, int w, int h);
};
void Box::set(int l, int w, int h) {
    length = l;
    width = w;
    height = h;
}

int main() {
    Box box;
    box.show();  // 6

    box.set(2, 3, 4);
    box.show();  // 24
    return 0;
}
```

## 四、访问权限

通过「成员访问限定符」来控制成员变量和成员函数的访问权限：

- public 公有的
- protected 受保护的
- private私有的

在类的内部，无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。

在类的外部，只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。

但在派生类内部，protected 属性的成员可以访问。

```c++
#include <iostream>
using namespace std;
//类的声明
class Student {
private:  //私有的
    string m_name;
    int m_age;

public:  //共有的
    void setname(string name);
    void setage(int age);
    void show();
};
//成员函数的定义
void Student::setname(string name) {
    m_name = name;
}
void Student::setage(int age) {
    m_age = age;
}
void Student::show() {
    cout << m_name << " " << m_age << endl;
}

int main() {
    //在栈上创建对象
    Student stu;
    stu.setname("dodo");
    stu.setage(10);
    stu.show();  // dodo 10
    //在堆上创建对象
    Student *pstu = new Student;
    pstu->setname("keke");
    pstu->setage(20);
    pstu->show();  // keke 20
    return 0;
}

```

## 五、封装

根据C++软件设计规范，实际项目开发中的成员变量以及只在类内部使用的成员函数（只被成员函数调用的成员函数）都建议声明为 private，而只将允许通过对象调用的成员函数声明为 public。

对于不可访问的成员变量，可以额外添加两个 public 属性的成员函数，一个用来设置（set）成员变量的值，一个用来获取（get）成员变量的值

**这种将成员变量声明为 private、将部分成员函数声明为 public 的做法体现了类的封装性。所谓封装，是指尽量隐藏类的内部实现，只向用户提供有用的成员函数。**

## 六、构造函数

构造函数（Constructor），在创建对象时自动执行。构造函数的名字和类名相同，创建对象时要将对象名后面加上 `(arg1, ...)` ，表示构造函数被调用。

- 构造函数必须是 public 属性
- 无论声明、定义，函数名前面都不能出现返回值类型，包括 void
- 函数体中不能有 return 语句

```c++
#include <iostream>
using namespace std;

class Student {
private:
    string m_name;
    int m_age;
    float m_score;

public:
    //声明构造函数
    Student(string name, int age, float score);
    //声明普通成员函数
    void show();
};

//定义构造函数
Student::Student(string name, int age, float score) {
    m_name = name;
    m_age = age;
    m_score = score;
}
//定义普通成员函数
void Student::show() {
    cout << m_name << " " << m_age << " " << m_score << endl;
}

int main() {
    //创建对象时向构造函数传参
    Student stu("doo", 15, 92.5f);
    stu.show();  // doo 15 92.5
    
    //创建对象时向构造函数传参
    Student *pstu = new Student("kee", 16, 96);
    pstu->show();  // kee 16 96

    return 0;
}
```

### 构造函数的重载

和普通成员函数一样，构造函数是允许重载的。**一个类可以有多个重载的构造函数，创建对象时根据传递的实参来判断调用哪一个构造函数。**

```c++
#include <iostream>
using namespace std;

class Student {
private:
    string m_name;
    int m_age;

public:
    // 声明两个构造函数
    Student();
    Student(string, int);
    void show();  // 声明成员函数
};

Student::Student() {
    m_name = "doo";
    m_age = 10;
}
Student::Student(string name, int age) {
    m_name = name;
    m_age = age;
}
void Student::show() {
    cout << m_name << " " << m_age << endl;
}

int main() {
    Student stu1;
    stu1.show();  // doo 10

    Student *pstu = new Student("kee", 20);
    pstu->show();  // kee 20
}
```

### 初始化列表

使用构造函数初始化列表并没有效率上的优势，仅仅是书写方便，尤其是成员变量较多时，这种写法非常简单明了。

```c++
#include <iostream>
using namespace std;

class Student {
private:
    string m_name;
    int m_age;

public:
    Student(string, int);
    void show();
};
//采用初始化列表
Student::Student(string name, int age) : m_name(name), m_age(age) {
    // TODO
}
void Student::show() {
    cout << m_name << " " << m_age << endl;
}

int main() {
    Student stu("doo", 10);
    stu.show();  // doo 10
}
```

### 初始化 const 成员变量

初始化 const 成员变量的唯一方法就是使用初始化列表。

```c++
#include <iostream>
using namespace std;

class Student {
private:
    string m_name;
    int m_age;
    const int m_idx;

public:
    Student(string, int, int);
    void show();
};
// const 成员变量，必须采用初始化列表
Student::Student(string name, int age, int idx) : m_idx(idx) {
    m_name = name;
    m_age = age;
}
void Student::show() {
    cout << m_name << " " << m_age << " " << m_idx << endl;
}

int main() {
    Student stu("doo", 10, 9999);
    stu.show();  // doo 10 9999
}
```

## 七、析构函数

析构函数（Destructor），销毁对象时系统会自动调用这个函数来进行清理工作，例如释放分配的内存、关闭打开的文件等。析构函数的名字是在类名前面加一个 `~` 符号

- 没有参数
- 不能被重载，因此一个类只能有一个析构函数
- 不需要程序员显式调用（程序员也没法显式调用）

**new 和 delete 与C语言中 malloc()、free() 最大的一个不同之处在于：用 new 分配内存时会调用构造函数，用 delete 释放内存时会调用析构函数。**构造函数和析构函数对于类来说是不可或缺的，所以在C++中我们非常鼓励使用 new 和 delete。

例子：用 VLA 类来模拟变长数组，它使用一个构造函数为数组分配内存，使用一个析构函数在数组被销毁后，释放已经分配的内存

```c++
#include <iostream>
using namespace std;

class VAL {
public:
    VAL(int len);  // 构造函数
    ~VAL();        // 析构函数

    void input();  // 从控制台输入数组元素
    void show();   // 显示数组元素
private:
    const int m_len;  // 数组长度，常量
    int *m_arr;       // 数组指针
    int *m_p;         // 指向数组的第i个元素的指针

    int *at(int i);  // 获取第i个元素的指针
};

VAL::VAL(int len) : m_len(len) {
    if (len > 0) {
        m_arr = new int[len];  // 分配内存
    } else {
        m_arr = NULL;
    }
}
VAL::~VAL() {
    delete[] m_arr;  // 释放内存
}
void VAL::input() {
    cout << "Input array element: ";
    for (int i = 0; m_p = at(i); i++) {
        cin >> *at(i);
    }
}
void VAL::show() {
    for (int i = 0; m_p = at(i); i++) {
        if (i == m_len - 1) {
            cout << *at(i) << endl;
        } else {
            cout << *at(i) << ", ";
        }
    }
}
int *VAL::at(int i) {
    if (!m_arr || i < 0 || i >= m_len) {
        return NULL;
    } else {
        return m_arr + i;
    }
}

int main() {
    int n;
    cout << "Input array length: ";
    cin >> n;  // 5

    // 在堆区创建对象，调用构造函数分配数组内存
    VAL *parr = new VAL(n);

    parr->input();  // 输入数组元素 1 2 3 4 5
    parr->show();   // 显示数组元素 1, 2, 3, 4, 5

    delete parr;  // 删除对象，调用构造函数释放数组内存
}
```

### 析构函数的执行时机

析构函数在对象被销毁时调用，而对象的销毁时机与它所在的内存区域有关

- 在所有函数之外创建的对象是全局对象，它和全局变量类似，位于内存分区中的全局数据区，程序在结束执行时会调用这些对象的析构函数。

- 在函数内部创建的对象是局部对象，它和局部变量类似，位于栈区，函数执行结束时会调用这些对象的析构函数。

- new 创建的对象位于堆区，通过 delete 删除时才会调用析构函数；如果没有 delete，析构函数就不会被执行。

```c++
#include <iostream>
#include <string>
using namespace std;

class Demo {
public:
    Demo(string s);
    ~Demo();

private:
    string m_s;
};
Demo::Demo(string s) : m_s(s) {}
Demo::~Demo() { cout << m_s << endl; }

void func() {
    //局部对象
    Demo obj1("1");
}

//全局对象
Demo obj2("2");

int main() {
    //局部对象
    Demo obj3("3");
    // new创建的对象
    Demo *pobj4 = new Demo("4");
    func();
    cout << "main" << endl;

    return 0;
}
```

