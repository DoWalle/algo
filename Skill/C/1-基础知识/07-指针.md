# 指针

将内存中字节的编号称为地址（Address）或指针（Pointer）

如何输出一个地址：

```c
#include <stdio.h>
int main(){
    int a = 100;
    char str[20] = "hello world";
    printf("%#X, %#X\n", &a, str);
    return 0;
}

// 0X6C9B448C, 0X6C9B4490
```

`%#X`表示以十六进制形式输出，并附带前缀`0X`。a 是一个变量，用来存放整数，需要在前面加`&`来获得它的地址；str 本身就表示字符串的首地址，不需要加`&`。

> C语言中有一个控制符`%p`，专门用来以十六进制形式输出地址，不过 %p 的输出格式并不统一，有的编译器带`0x`前缀，有的不带，所以此处我们并没有采用。

## 一、指针变量的定义和使用

数据在内存中的地址也称为指针，如果一个变量存储了一份数据的指针，我们就称它为**指针变量**。

在C语言中，允许用一个变量来存放指针，这种变量称为指针变量。指针变量的值就是某份数据的地址，这样的一份数据可以是数组、字符串、函数，也可以是另外的一个普通变量或指针变量。

### 1、定义指针变量

定义指针变量与定义普通变量非常类似，不过要在变量名前面加星号`*`，格式为：

```c
datatype *name;
datatype *name = value;
```

`*`表示这是一个指针变量，`datatype`表示该指针变量所指向的数据的类型 。例如：

```c
int *p1;
int a = 100;
int *p_a = &a;
```

和普通变量一样，指针变量也可以被多次写入，只要你想，随时都能够改变指针变量的值，请看下面的代码：

```c
//定义普通变量
float a = 99.5, b = 10.6;
char c = '@', d = '#';
//定义指针变量
float *p1 = &a;
char *p2 = &c;
//修改指针变量的值
p1 = &b;
p2 = &d;
```

`*`是一个特殊符号，表明一个变量是指针变量，定义 p1、p2 时必须带`*`。而给 p1、p2 赋值时，因为已经知道了它是一个指针变量，就没必要多此一举再带上`*`，后边可以像使用普通变量一样来使用指针变量。也就是说，**定义指针变量时必须带`*`，给指针变量赋值时不能带`*`**。

指针变量也可以连续定义，例如：

```c
int *a, *b, *c;  //a、b、c 的类型都是 int*
```

### 2、通过指针变量取得数据

指针变量存储了数据的地址，通过指针变量能够获得该地址上的数据，格式为：

```
*pointer;
```

这里的`*`称为指针运算符，用来取得某个地址上的数据，

```c
#include <stdio.h>
int main(){
    int a = 15;
    int *p = &a;
    printf("%d, %d\n", a, *p);  //两种方式都可以输出a的值
    return 0;
}
```

### 3、修改内存上的数据

```c
#include <stdio.h>
int main(){
    int a = 15, b = 99, c = 222;
    int *p = &a;  //定义指针变量
    *p = b;  //通过指针变量修改内存上的数据
    c = *p;  //通过指针变量获取内存上的数据
    printf("%d, %d, %d, %d\n", a, b, c, *p);
    return 0;
}
// 99, 99, 99, 99
```

【示例】通过指针交换两个变量的值。

```c
#include <stdio.h>

int main(){
    int a = 100, b = 999, temp;
    int *pa = &a, *pb = &b;
    printf("a=%d, b=%d\n", a, b);
    
    /*****开始交换*****/
    temp = *pa;  //将a的值先保存起来
    *pa = *pb;  //将b的值交给a
    *pb = temp;  //再将保存起来的a的值交给b
    /*****结束交换*****/
    
    printf("a=%d, b=%d\n", a, b);
    return 0;
}
```

### 4、关于 * 和 & 的谜题

假设有一个 int 类型的变量 a，pa 是指向它的指针，那么`*&a`和`&*pa`分别是什么意思呢？

`*&a`可以理解为`*(&a)`，`&a`表示取变量 a 的地址（等价于 pa），`*(&a)`表示取这个地址上的数据（等价于 *pa），绕来绕去，又回到了原点，`*&a`仍然等价于 a。

`&*pa`可以理解为`&(*pa)`，`*pa`表示取得 pa 指向的数据（等价于 a），`&(*pa)`表示数据的地址（等价于 &a），所以`&*pa`等价于 pa。

### 5、对星号`*`的总结

在我们目前所学到的语法中，星号`*`主要有三种用途：

- 表示乘法，例如`int a = 3, b = 5, c;  c = a * b;`，这是最容易理解的。
- 表示定义一个指针变量，以和普通变量区分开，例如`int a = 100;  int *p = &a;`。
- 表示获取指针指向的数据，是一种间接操作，例如`int a, b, *p = &a;  *p = 100;  b = *p;`。

## 二、指针变量的运算

指针变量保存的是地址，而地址本质上是一个整数，所以指针变量可以进行部分运算，例如加法、减法、比较等，

```c
#include <stdio.h>
int main() {
    int a = 10, *pa = &a, *paa = &a;
    double b = 99.9, *pb = &b;
    char c = '@', *pc = &c;

    //最初的值
    printf("&a=%#X, &b=%#X, &c=%#X\n", &a, &b, &c);
    printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc);

    //加法运算
    pa++;
    pb++;
    pc++;
    printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc);

    //减法运算
    pa -= 2;
    pb -= 2;
    pc -= 2;
    printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc);
    
    //比较运算
    if (pa == paa) {
        printf("%d\n", *paa);
    } else {
        printf("%d\n", *pa);
    }
    return 0;
}

// &a=0X15E79EFC, &b=0X15E79F00, &c=0X15E79EFB
// pa=0X15E79EFC, pb=0X15E79F00, pc=0X15E79EFB
// pa=0X15E79F00, pb=0X15E79F08, pc=0X15E79EFC
// pa=0X15E79EF8, pb=0X15E79EF8, pc=0X15E79EFA
// 1087416381
```

从运算结果可以看出：pa、pb、pc 每次加 1，它们的地址分别增加 4、8、1，正好是 int、double、char 类型的长度；减 2 时，地址分别减少 8、16、2，正好是 int、double、char 类型长度的 2 倍

**指针变量加减运算的结果跟数据类型的长度有关，而不是简单地加 1 或减 1**

下面的例子是一个反面教材，警告读者不要尝试通过指针获取下一个变量的地址：

```c
#include <stdio.h>
int main(){
    int a = 1, b = 2, c = 3;
    int *p = &c;
    int i;
    for(i=0; i<8; i++){
        printf("%d, ", *(p+i) );
    }
    return 0;
}
// 3, 1, 1, 2, 1596383328, 32767, -8460800, -1106343347,
```

变量 a、b、c 并不挨着

不能对指针变量进行乘法、除法、取余等其他运算，除了会发生语法错误，也没有实际的含义。

## 三、数组指针（指向数组的指针）

数组（Array）是一系列具有相同类型的数据的集合，每一份数据叫做一个数组元素（Element）。数组中的所有元素在内存中是连续排列的，整个数组占用的是一块内存。以`int arr[] = { 99, 15, 100, 888, 252 };`为例，该数组在内存中的分布如下图所示：

![img](http://c.biancheng.net/uploads/allimg/190114/1J35014B-0.jpg)

**定义数组时，要给出数组名和数组长度，数组名可以认为是一个指针，它指向数组的第 0 个元素**。在C语言中，我们将第 0 个元素的地址称为数组的首地址。以上面的数组为例，下图是 arr 的指向：

![img](http://c.biancheng.net/uploads/allimg/190114/1J3506331-1.jpg)

> 数组名的本意是表示整个数组，也就是表示多份数据的集合，但在使用过程中经常会转换为指向数组第 0 个元素的指针，所以上面使用了“认为”一词，表示数组名和数组首地址并不总是等价。

例子演示了如何以指针的方式遍历数组元素：

```c
#include <stdio.h>
int main(){
    int arr[] = { 99, 15, 100, 888, 252 };
    int len = sizeof(arr) / sizeof(int);  //求数组长度
    int i;
    for(i=0; i<len; i++){
        printf("%d  ", *(arr+i) );  //*(arr+i)等价于arr[i]
    }
    printf("\n");
    return 0;
}
```

> arr 是`int*`类型的指针，每次加 1 时它自身的值会增加 sizeof(int)，加 i 时自身的值会增加 sizeof(int) * i

可以定义一个指向数组的指针，例如：

```c
int arr[] = { 99, 15, 100, 888, 252 };
int *p = arr;
```

arr 本身就是一个指针，可以直接赋值给指针变量 p。arr 是数组第 0 个元素的地址，所以`int *p = arr;`也可以写作`int *p = &arr[0];`。也就是说，arr、p、&arr[0] 这三种写法都是等价的，它们都指向数组第 0 个元素，或者说指向数组的开头。

如果一个指针指向了数组，我们就称它为**数组指针**（Array Pointer）。

更改上面的代码，使用数组指针来遍历数组元素：

```c
#include <stdio.h>

int main(){
    int arr[] = { 99, 15, 100, 888, 252 };
    int i, *p = arr, len = sizeof(arr) / sizeof(int);
    for(i=0; i<len; i++){
        printf("%d  ", *(p+i) );
    }
    printf("\n");
    return 0;
}
```

数组在内存中只是数组元素的简单排列，没有开始和结束标志，在求数组的长度时不能使用`sizeof(p) / sizeof(int)`，因为 p 只是一个指向 int 类型的指针，编译器并不知道它指向的到底是一个整数还是一系列整数（数组），所以 sizeof(p) 求得的是 p 这个指针变量本身所占用的字节数，而不是整个数组占用的字节数。

让 p 指向数组中的第二个元素：

```c
#include <stdio.h>

int main(){
    int arr[] = { 99, 15, 100, 888, 252 };
    int *p = &arr[2];  //也可以写作 int *p = arr + 2;
    printf("%d, %d, %d, %d, %d\n", *(p-2), *(p-1), *p, *(p+1), *(p+2) );
    return 0;
}
// 99, 15, 100, 888, 252
```

### 1、访问数组元素

引入数组指针后，我们就有两种方案来访问数组元素了，一种是使用下标，另外一种是使用指针。

#### 1) 使用下标

也就是采用 arr[i] 的形式访问数组元素。如果 p 是指向数组 arr 的指针，那么也可以使用 p[i] 来访问数组元素，它等价于 arr[i]。

#### 2) 使用指针

也就是使用 *(p+i) 的形式访问数组元素。另外数组名本身也是指针，也可以使用 *(arr+i) 来访问数组元素，它等价于 *(p+i)。

不管是数组名还是数组指针，都可以使用上面的两种方式来访问数组元素。不同的是，数组名是常量，它的值不能改变，而数组指针是变量（除非特别指明它是常量），它的值可以任意改变。也就是说，数组名只能指向数组的开头，而数组指针可以先指向数组开头，再指向其他元素。

借助自增运算符来遍历数组元素：

```c
#include <stdio.h>
int main(){
    int arr[] = { 99, 15, 100, 888, 252 };
    int i, *p = arr, len = sizeof(arr) / sizeof(int);
    for(i=0; i<len; i++){
        printf("%d  ", *p++ );
    }
    printf("\n");
    return 0;
}
```

### 2、字符串指针

C语言中没有特定的字符串类型，我们通常是将字符串放在一个字符数组中

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str[] = "hello world";
    int len = strlen(str), i;
    //直接输出字符串
    printf("%s\n", str);
    //每次输出一个字符
    for (i = 0; i < len; i++) {
        printf("%c", str[i]);
    }
    printf("\n");
    return 0;
}
```

字符数组归根结底还是一个数组，使用指针的方式来输出字符串

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str[] = "hello world";
    char *pstr = str;
    int len = strlen(str), i;
    //使用*(pstr+i)
    for (i = 0; i < len; i++) {
        printf("%c", *(pstr + i));
    }
    printf("\n");
    //使用pstr[i]
    for (i = 0; i < len; i++) {
        printf("%c", pstr[i]);
    }
    printf("\n");
    //使用*(str+i)
    for (i = 0; i < len; i++) {
        printf("%c", *(str + i));
    }
    printf("\n");
    return 0;
}
```

除了字符数组，C语言还支持另外一种表示字符串的方法，就是直接使用一个指针指向字符串，例如：

```c
char *str = "hello world";

char *str;
str = "hello world";
```

输出这种字符串：

```c
#include <stdio.h>
#include <string.h>
int main(){
    char *str = "hello world";
    int len = strlen(str), i;
   
    //直接输出字符串
    printf("%s\n", str);
    //使用*(str+i)
    for(i=0; i<len; i++){
        printf("%c", *(str+i));
    }
    printf("\n");
    //使用str[i]
    for(i=0; i<len; i++){
        printf("%c", str[i]);
    }
    printf("\n");
    return 0;
}
```

这一切看起来和字符数组是多么地相似，它们都可以使用`%s`输出整个字符串，都可以使用`*`或`[ ]`获取单个字符，这两种表示字符串的方式是不是就没有区别了呢？

**有！它们最根本的区别是在内存中的存储区域不一样，字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限**。

到底使用字符数组还是字符串常量？

- 在编程过程中如果只涉及到对字符串的读取，那么字符数组和字符串常量都能够满足要求；
- 如果有写入（修改）操作，那么只能使用字符数组，不能使用字符串常量。

### 3、数组灵活多变的访问形式

C语言中的指针使得代码的编写非常灵活，如果指针能够和数组结合，那将会有更多的“花招”

```c
#include <stdio.h>
int main() {
    char str[20] = "hello world";

    char *s1 = str;
    char *s2 = str + 2;

    char c1 = str[4];
    char c2 = *str;
    char c3 = *(str + 4);
    char c4 = *str + 2;
    char c5 = (str + 1)[5];

    int num1 = *str + 2;
    long num2 = (long)str;
    long num3 = (long)(str + 2);
    printf("  s1 = %s\n", s1);
    printf("  s2 = %s\n", s2);
    printf("  c1 = %c\n", c1);
    printf("  c2 = %c\n", c2);
    printf("  c3 = %c\n", c3);
    printf("  c4 = %c\n", c4);
    printf("  c5 = %c\n", c5);

    printf("num1 = %d\n", num1);
    printf("num2 = %ld\n", num2);
    printf("num3 = %ld\n", num3);
    return 0;
}
//   s1 = hello world
//   s2 = llo world
//   c1 = o
//   c2 = h
//   c3 = o
//   c4 = j
//   c5 = w
// num1 = 106
// num2 = 140702053822608
// num3 = 140702053822610
```

\1) str 既是数组名称，也是一个指向字符串的指针；指针可以参加运算，加 1 相当于数组下标加 1。

printf() 输出字符串时，要求给出一个起始地址，并从这个地址开始输出，直到遇见字符串结束标志`\0`。s1 为字符串 str 第 0 个字符的地址，s2 为第 2 个字符的地址，所以 printf() 的结果分别为 c.biancheng.net 和 biancheng.net。

\2) 指针可以参加运算，str+4 表示第 4 个字符的地址，c3 = *(str+4) 表示第4个字符，即 'a'。

\3) 其实，数组元素的访问形式可以看做 address[offset]，address 为起始地址，offset 为偏移量：`c1 = str[4]`表示以地址 str 为起点，向后偏移4个字符，为 'a'；`c5 = (str+1)[5]`表示以地址 str+1 为起点，向后偏移5个字符，等价于str[6]，为 'c'。

\4) 字符与整数运算时，先转换为整数（字符对应的ASCII码）。num1 与 c4 右边的表达式相同，对于 num1，*str+2 == 'c'+2 == 99+2 == 101，即 num1 的值为 101，对于 c4，101 对应的字符为 ‘e’，所以 c4 的输出值为 'e'。

\5) num2 和 num3 分别为字符串 str 的首地址和第 2 个元素的地址

```c
#include <stdio.h>
#include <stdlib.h>
int main() {
    char str[20] = {0};
    int i;
    for (i = 0; i < 10; i++) {
        *(str + i) = 97 + i;  // 97为字符a的ASCII码值
    }

    printf("%s\n", str);
    printf("%s\n", str + 2);
    printf("%c\n", str[2]);
    printf("%c\n", (str + 2)[2]);

    return 0;
}
// abcdefghij
// cdefghij
// c
// e
```

## 四、指针变量作为函数参数

### 1、指针变量作参数

```c
#include <stdio.h>
void swap(int *p1, int *p2) {
    int temp;  //临时变量
    temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}
int main() {
    int a = 66, b = 99;
    swap(&a, &b);
    printf("a = %d, b = %d\n", a, b);
    return 0;
}
```

### 2、用数组作函数参数

参数 intArr 仅仅是一个数组指针，在函数内部无法通过这个指针获得数组长度，必须将数组长度作为函数参数传递到函数内部。

```c
#include <stdio.h>

int max(int *intArr, int len) {
    int i, maxValue = intArr[0];  //假设第0个元素是最大值
    for (i = 1; i < len; i++) {
        if (maxValue < intArr[i]) {
            maxValue = intArr[i];
        }
    }
    return maxValue;
}

int main() {
    int nums[6], i;
    int len = sizeof(nums) / sizeof(int);
    //读取用户输入的数据并赋值给数组元素
    for (i = 0; i < len; i++) {
        scanf("%d", nums + i);
    }
    printf("Max value is %d!\n", max(nums, len));
    return 0;
}
```

用数组做函数参数时，参数也能够以“真正”的数组形式给出。

```c
int max(int intArr[6], int len){
    int i, maxValue = intArr[0];  //假设第0个元素是最大值
    for(i=1; i<len; i++){
        if(maxValue < intArr[i]){
            maxValue = intArr[i];
        }
    }
    return maxValue;
}
```

简写

```c
int max(int intArr[], int len){
    int i, maxValue = intArr[0];  //假设第0个元素是最大值
    for(i=1; i<len; i++){
        if(maxValue < intArr[i]){
            maxValue = intArr[i];
        }
    }
    return maxValue;
}
```

实际上这两种形式的数组定义都是假象，不管是`int intArr[6]`还是`int intArr[]`都不会创建一个数组出来，编译器也不会为它们分配内存，实际的数组是不存在的，它们最终还是会转换为`int *intArr`这样的指针。这就意味着，两种形式都不能将数组的所有元素“一股脑”传递进来，大家还得规规矩矩使用数组指针。

`int intArr[6]`这种形式只能说明函数期望用户传递的数组有 6 个元素，并不意味着数组只能有 6 个元素，真正传递的数组可以有少于或多于 6 个的元素。

需要强调的是，不管使用哪种方式传递数组，都不能在函数内部求得数组长度，因为 intArr 仅仅是一个指针，而不是真正的数组，所以必须要额外增加一个参数来传递数组长度。

C语言为什么不允许直接传递数组的所有元素，而必须传递数组指针呢？

**参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上**。

对于像 int、float、char 等基本类型的数据，它们占用的内存往往只有几个字节，对它们进行内存拷贝非常快速。而数组是一系列数据的集合，数据的数量没有限制，可能很少，也可能成千上万，对它们进行内存拷贝有可能是一个漫长的过程，会严重拖慢程序的效率，为了防止技艺不佳的程序员写出低效的代码，C语言没有从语法上支持数据集合的直接赋值。
