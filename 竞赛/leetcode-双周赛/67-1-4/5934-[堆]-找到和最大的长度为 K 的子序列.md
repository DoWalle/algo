#### [5934. 找到和最大的长度为 K 的子序列](https://leetcode-cn.com/problems/find-subsequence-of-length-k-with-the-largest-sum/)

欢迎 star :) https://github.com/WalleDong/algorithm

思路一：超时 递归

首先想到的是递归，但是下面的提示，**`1 <= nums.length <= 1000`，如果不使用剪枝的递归话，肯定超时**。

而这一题似乎没法剪枝

```python
class Solution:
    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:
        sz = len(nums)
        self.sub_sum = float('-inf')
        self.ans = None
        
        def dfs(begin, path):
            if len(path) == k:
                tmp = sum(path)
                if tmp > self.sub_sum:
                    self.ans = path[:]
                    self.sub_sum = tmp
                return
            for i in range(begin, sz):
                path.append(nums[i])
                dfs(i+1, path)
                path.pop()
        dfs(0, [])
        return self.ans

```

思路二：带权的大根堆

每个元素进入堆里面，从堆里面 pop 出前面 k 个元素，按照元素在nums中的index排序，最后汇总

时间复杂度：`O(n*log(n))`

空间复杂度：`O(n)` 

```python
class Solution:
    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:
        
        big_hp = []
        for i, v in enumerate(nums):
            heapq.heappush(big_hp, (-v, i))
        tmp = []
        for _ in range(k):
            v, i = heapq.heappop(big_hp) 
            tmp.append((-v, i))
        # print(tmp)
        tmp.sort(key=lambda x: x[1])
        ans = []
        for i in range(k):
            ans.append(tmp[i][0])
        return ans

```

