# Introduction and Examples

## 1.1 课程内容简介（课程目标、操作系统目标）

**这门课程的目标**：

1. 理解操作系统的设计和实现。设计是指整体的结构，实现是指具体的代码长什么样。对于这两者，我们都会花费大量时间讲解。
2. 为了深入了解具体的工作原理，你们可以通过一个小的叫做XV6的操作系统，获得实际动手经验。通过研究现有的操作系统，并结合课程配套的实验，你可以获得扩展操作系统，修改并提升操作系统的相关经验，并且能够通过操作系统接口，编写系统软件。

**操作系统的目标**：

1. 第一个就是「**抽象硬件**」。通常来说，你会买一个计算机，里面包含了CPU，内存，但是这是一种非常低层级的资源。幸好我们有一些应用程序实现了高层级的接口和抽象，例如进程，文件系统。这些高层级的接口和抽象（Abstraction）方便了应用的开发，也提供了更好的移植性。
2. 操作系统的另一个重要的任务是：在多个应用程序之间「**共用硬件资源**」。你可以在一个操作系统同时运行文本编辑器，程序编译器，多个数据库等等。操作系统能非常神奇的在不相互干扰的前提下，同时运行这些程序。这里通常被称为multiplex。
3. 因为在操作系统中可能同时运行很多程序，即使程序出现了故障，多个程序之间互不干扰就变得非常重要。所以这里需要「**隔离性**（Isolation）」，不同的活动之间不能相互干扰。
4. 但是另一方便，不同的活动之间有时又想要相互影响，比如说数据交互，协同完成任务等。举个例子，我通过文本编辑器创建了一个文件，并且我希望我的编译器能读取文件，我绝对想要数据能共享。所以，我们希望能在需要的时候实现「**共享**（Sharing）」。
5. 但是在很多场景下，用户并不想要共享，比如你登录到了一个公共的计算机，例如Athena，你不会想要其他人来读取你的文件。所以在共享的同时，我们也希望在没有必要的时候不共享。这里我们称为Security或者Permission System或者是**Access Control System**。
6. 另一个人们认为操作系统应该具有的价值是：如果你在硬件上花费了大量的金钱，你会期望你的应用程序拥有硬件应该提供的完整性能，但是很多时候你只负责应用程序编程，你会期望操作系统也必须保证自身提供的服务不会阻止应用程序获得高性能。所以操作系统需要至少不阻止应用程序获得高性能，甚至需要帮助应用程序获得「**高性能**」（Performance）。
7. 最后，对于大部分操作系统，必须要支持大量不同类型的应用程序，或许这是一个笔记本，正在运行文本编辑器，正在运行游戏，或许你的操作系统需要支持数据库服务器和云计算。通常来说，设计并构造一个操作系统代价是非常大的，所以人们总是希望在相同的操作系统上，例如Linux，运行大量的任务。我认为大部分人都已经跑过Linux，并使用了我刚刚描述的所有的场景。所以，同一个操作系统需要能够支持大量「**不同的用户场景**」。

## 1.2 操作系统结构

过去几十年，人们将一些**分层的设计思想**加入到操作系统中，并运行的很好。我将会为你列出操作系统经典的组织结构，这个组织结构同时也是这门课程的主要内容，这里的组织结构对于操作系统来说还是挺常见的。

- 用一个矩形表示一个计算机
- 这个计算机有一些**硬件资源**，我会将它放在矩形的下面，硬件资源包括了CPU，内存，磁盘，网卡。所以硬件资源在最低一层
- 在这个架构的最上层，我们会运行各种各样的应用程序，或许有一个文本编辑器（VI），或许有一个C编译器（CC），你还可以运行大量我们今天会讨论的其他事物，例如作为CLI存在的Shell，所以这些就是正在运行的所有程序。这里程序都运行在同一个空间中，这个空间通常会被称为**用户空间**（Userspace）。
- 区别于用户空间程序，有一个特殊的程序总是会在运行，**它称为Kernel**。Kernel是计算机资源的守护者。当你打开计算机时，Kernel总是第一个被启动。Kernel程序只有一个，它维护数据来管理每一个用户空间进程。Kernel同时还维护了大量的数据结构来帮助它管理各种各样的硬件资源，以供用户空间的程序使用。Kernel同时还有大量内置的服务，例如，Kernel通常会有文件系统实现类似文件名，文件内容，目录的东西，并理解如何将文件存储在磁盘中。所以用户空间的程序会与Kernel中的文件系统交互，文件系统再与磁盘交互。

在这门课程中，**我们主要关注点在Kernel、连接Kernal和用户空间程序的接口、Kernel内软件的架构**。所以，我们会关心Kernel中的服务，其中一个服务是「文件系统」，另一个就是「进程管理系统」。每一个用户空间程序都被称为一个进程，它们有自己的内存和共享的CPU时间。同时，Kernel会管理内存的分配。不同的进程需要不同数量的内存，Kernel会复用内存、划分内存，并为所有的进程分配内存。

文件系统通常有一些逻辑分区。目前而言，我们可以认为文件系统的作用是管理文件内容并找出文件具体在磁盘中的哪个位置。文件系统还维护了一个独立的命名空间，其中每个文件都有文件名，并且命名空间中有一个层级的目录，每个目录包含了一些文件。所有这些都被文件系统所管理。

这里还有一些安全的考虑，我们可以称之为Access Control。当一个进程想要使用某些资源时，比如读取磁盘中的数据，使用某些内存，Kernel中的Access Control机制会决定是否允许这样的操作。对于一个分时共享的计算机，例如Athena系统，这里可能会变得很复杂。因为在Athena系统中，每一个进程可能属于不同的用户，因此会有不同Access规则来约定哪些资源可以被访问。

![6s081-1](./doc/6s081-1.png)

我们同时也对应用程序是如何与Kernel交互，它们之间的接口长什么样感兴趣。这里通常成为**Kernel的API，它决定了应用程序如何访问Kernel**。通常来说，这里是通过所谓的系统调用（System Call）来完成。系统调用与程序中的函数调用看起来是一样的，但区别是系统调用会实际运行到系统内核中，并执行内核中对于系统调用的实现。在这门课程的后面，我会详细介绍系统调用。现在，我只会介绍一些系统调用在应用程序中是长什么样的。

## 1.3 why hard and interesting

学习操作系统比较难的一个原因是，**内核的编程环境比较困难**。当你在编写、修改，扩展内核，或者写一个新的操作系统内核时，你实际上在提供一个基础设施让别人来运行他们的程序。当程序员在写普通的应用程序时，应用程序下面都是操作系统。而当我们在构建操作系统时，在操作系统下面就是硬件了，这些硬件通常会更难处理。

学习操作系统比较难的另一个原因是，当你在设计一个操作系统时，你需要满足一些列矛盾的需求。

- 其中一个是，你想要你的**操作系统既高效又易用**。高效通常意味着操作系统需要在离硬件近的low-level进行操作，而易用则要求操作系统为应用程序提供抽象的high-level可移植接口。所以，提供一个简单可移植，同时又高效的抽象接口需要一定的技巧。
- 另一个矛盾的点是，我们想要提供一个非常强大的操作系统服务，这样操作系统才能分担运行应用程序的负担，所以**我们需要强大的操作系统服务。但同时，我们也想要有简单的接口**。我们不想程序员看到数量巨多，复杂且难以理解的的内核接口。因为，如果他们不理解这些接口，他们就会很难使用这些接口。所以，我们也想要简单的API。实际上是有可能提供既简单，同时又包含强大功能的接口。所以，这里要提供一个简单的接口，同时又包含了强大的功能。
- 最后一个矛盾点是所有的操作系统需要满足的。你希望**给与应用程序尽可能多的灵活性**，你不会想要限制应用程序，所以你需要**内核具备灵活的接口**。但是另一方面，你的确需要在某种程度上**限制应用程序**，因为你会想要**安全性**。我们希望给程序员完全的自由，但是实际上又不能是真正的完全自由，因为我们不想要程序员能直接访问到硬件，干扰到其他的应用程序，或者干扰操作系统的行为。

这里也有一些更加实际的原因来告诉你为什么会选择这门课程。

- 其中一个原因是，如果你**对于计算机的运行原理感兴趣**，对于你打开计算机以后实际发生的事情感兴趣，那么这门课程你就选对了。
- 类似的，如果你**喜欢基础架构**，比如你喜欢构建一些其他程序可以使用的服务，那么这门课程都是有关基础架构的内容，因为操作系统就是基础架构。
- 如果你曾经**花费了大量的时间来定位应用程序的Bug**，或者定位安全的问题，那么你会发现这些经历通常需要理解操作系统是如何运作的。比如从根本上来说，操作系统涉及了很多安全相关的策略。当程序运行出错时，操作系统需要来收拾残局，而这一步也通常包括在定位问题中。

## 1.4 课程结构和资源

授课内容是这门课程的一大部分，**我们会讲解操作系统的基本概念。有几节课会专注于学习XV6中的代码**，XV6是我们的一个小的用于教学的操作系统，我们会介绍它是如何工作，查看它的代码，并在课程中演示代码的运行。在每一节课程之前都会有作业，作业会要求你们阅读介绍XV6的书籍，书籍的内容是XV6如何运行以及设计思想。所以你应该在课程之前完成相应的阅读，这样你才能理解课程的讨论内容。有几节课会专注于帮助你完成实验内容，例如**解释C语言是如何工作的，例如介绍RISC-V是如何工作的，这是我们将要使用的一个微处理器**。这些内容对于你们完成实验是有帮助的。在课程的结束部分，我们会花几节课时间来**阅读一些操作系统相关的论文**，包括一些研究论文和一些经典论文。我们会要求你在课程之前阅读这些论文，我们也会在课堂上讨论这些论文。几乎对于所有的课，我们会要求你对于阅读材料提出一些问题，我们会读取这些问题，以帮助我们决定课程上讲解什么内容，并且我们也会尽可能的回答这些问题。

这门课程的下一大部分是lab，几乎每周都会有一些编程实验。实验的意义在于帮助你获得一些使用和实现操作系统的实际动手经验。比如说，下周截止的实验实际上是**写一些应用程序代码来执行我们之前谈到的系统调用**，之后的大部分实验则要求你要么**实现基本的操作系统功能或者扩展XV6操作系统**。最后一个lab会要求你**添加一个网络协议栈和一个网络驱动**，这样操作系统才能连接到网络上。

## 1.5 read, write, exit系统调用

系统调用是操作系统提供的服务的接口，所以系统调用长什么样，应用程序期望从系统调用得到什么返回，系统调用是怎么工作的，这些还是挺重要的。

XV6是一个简化的类似Unix的操作系统，而Unix是一个老的操作系统，但是同时也是很多现代操作系统的基础，例如Linux，OSX。所以Unix使用的非常广泛。而作为我们教学用的操作系统，XV6就要简单的多。它是受Unix启发创造的，有着相同的文件结构，但是却要比任何真实的Unix操作系统都要简单的多。因为它足够简单，所以你们极有可能在几周内很直观的读完所有的代码，同时也把相应的书也看完，这样你们就能理解XV6内部发生的一切事情了。

XV6运行在一个RISC-V微处理器上，而RISC-V是MIT6.004课程讲解的处理器，所以你们很多人可能已经知道了RISC-V指令集。理论上，你可以在一个RISC-V计算机上运行XV6，已经有人这么做了。但是我们会在一个QEMU模拟器上运行XV6。

首先执行一下make clean，这样你们就能看到完整的编译过程。

之后我输入make qemu，这条指令会编译并构建xv6内核和所有的用户进程，并将它们运行在QEMU模拟器下。

## 1.6 open系统调用

## 1.7 Shell

## 1.8 fork系统调用

在第12行，我们调用了fork。fork会拷贝当前进程的内存，并创建一个新的进程，这里的内存包含了进程的指令和数据。之后，我们就有了两个拥有完全一样内存的进程。fork系统调用在两个进程中都会返回，**在原始的进程中，fork系统调用会返回大于0的整数，这个是新创建进程的ID。而在新创建的进程中，fork系统调用会返回0**。所以即使两个进程的内存是完全一样的，我们还是可以通过fork的返回值区分旧进程和新进程。

## 1.9 exec, wait系统调用

在接下来我展示的一个例子中，会使用echo，echo是一个非常简单的命令，它接收任何你传递给它的输入，并将输入写到输出。

代码会执行exec系统调用，这个系统调用会从指定的文件中读取并加载指令，并替代当前调用进程的指令。从某种程度上来说，这样相当于丢弃了调用进程的内存，并开始执行新加载的指令。所以第12行的系统调用exec会有这样的效果：操作系统从名为echo的文件中加载指令到当前的进程中，并替换了当前进程的内存，之后开始执行这些新加载的指令。同时，你可以传入命令行参数，exec允许你传入一个命令行参数的数组，这里就是一个C语言中的指针数组，在上面代码的第10行设置好了一个字符指针的数组，这里的字符指针本质就是一个字符串（string）。