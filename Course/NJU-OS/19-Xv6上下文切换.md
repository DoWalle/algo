# Xv6 上下文切换

## Overview

复习

- xv6 的系统调用实现：大家听得一头雾水，但留了个印象
    - ecall 指令：跳转到 trampoline 代码
    - 保存所有寄存器到 trapframe
    - 使内核代码能够继续执行

------

本次课回答的问题

- **Q**: 为什么要这么做？

------

本次课主要内容

- 上下文切换的原理与实现

## 一、处理器的虚拟化

### 1、今天借助代码回答一个根本性的问题

为什么死循环不能使计算机被彻底卡死？

原理上

- 硬件会发生中断 (类似于 “强行插入” 的 ecall)
- 切换到操作系统代码执行
- 操作系统代码可以切换到另一个进程执行

------

实际上

- （在代码层次）到底是如何发生的？
    - 上一次课调试了代码，有了第一印象
    - 今天再补充一些细节

### 2、热身：协程库

```python
def positive_integers():
    i = 0
    while i := i + 1:
        yield i
```

`positive_integers()` 并不是 “调用” 它执行

- 而是返回一个 generator
- generator 可以调用，到 yield 后 “封存” 状态
- 我们用这个特性实现了 [model-checker.py](http://jyywiki.cn/pages/OS/2022/demos/model-checker.py)

------

我们同样也可以在 C 里这么做

- `call yield` 切换到另一个执行流
    - 所有执行流共享内存
    - 拥有独立的寄存器和堆栈

### 3、复习：程序的状态

寄存器

- 32 个通用寄存器 + $pc
    - `$x0 ($zero), $x1 ($ra), ..., $x31`

------

内存

- $satp “配置” 出的地址空间
    - QEMU: info mem 查看
- 再次调试 initcode

------

持有的操作系统对象 (不可见)

- 程序只能看见 “文件描述符” (系统调用返回值, a0, syscall.c)
- 回顾 [minimal.S](http://jyywiki.cn/pages/OS/2022/demos/minimal.S)

什么是进程，pmap 看到的就是进程

还持有一些操作系统持有的对象，如文件描述符，就是进程状态的一部分

【40:00】