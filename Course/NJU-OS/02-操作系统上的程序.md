# 操作系统上的程序

## Overview

复习：操作系统

- 应用视角 (设计): 一组对象 (进程/文件/...) + API
- 硬件视角 (实现): 一个 C 程序

------

本次课回答的问题

- **Q**: 到底什么是 “程序”？

------

本次课主要内容

- 程序的状态机模型 (和编译器)
- 操作系统上的 {最小/一般/图形} 程序

## 一、数字电路与状态机

### 1、数字电路与状态机

数字逻辑电路

- 状态 = 寄存器保存的值 (flip-flop)
- 初始状态 = RESET (implementation dependent)
- 迁移 = 组合逻辑电路计算寄存器下一周期的值

### 2、数字逻辑电路：模拟器

```c
#include <stdio.h>
#include <unistd.h>

#define REGS_FOREACH(_)  _(X) _(Y)
#define RUN_LOGIC        X1 = !X && Y; \
                         Y1 = !X && !Y;
#define DEFINE(X)        static int X, X##1;
#define UPDATE(X)        X = X##1;
#define PRINT(X)         printf(#X " = %d; ", X);

int main() {
  REGS_FOREACH(DEFINE);
  while (1) { // clock
    RUN_LOGIC;
    REGS_FOREACH(PRINT);
    REGS_FOREACH(UPDATE);
    putchar('\n'); sleep(1);
  }
}
```

预编译的宏展开：`gcc -E a.c`

```c
int main() {
  static int X, X1; static int Y, Y1;;
  while (1) {
    X1 = !X && Y; Y1 = !X && !Y;;
    printf("X" " = %d; ", X); printf("Y" " = %d; ", Y);;
    X = X1; Y = Y1;;
    putchar('\n'); sleep(1);
  }
}
```

### 3、更完整的实现：数码管显示

输出数码管的配置信号

- [logisim.c](http://jyywiki.cn/pages/OS/2022/demos/logisim.c)
- 会编程，你就拥有全世界！
    - [seven-seg.py](http://jyywiki.cn/pages/OS/2022/demos/seven-seg.py)
    - 同样的方式可以模拟任何数字系统
        - 当然，也包括计算机系统

后端：logisim.c

```c
#include <stdio.h>
#include <unistd.h>

#define REGS_FOREACH(_)  _(X) _(Y)
#define OUTS_FOREACH(_)  _(A) _(B) _(C) _(D) _(E) _(F) _(G)
#define RUN_LOGIC        X1 = !X && Y; \
                         Y1 = !X && !Y; \
                         A  = (!X && !Y) || (X && !Y); \
                         B  = 1; \
                         C  = (!X && !Y) || (!X && Y); \
                         D  = (!X && !Y) || (X && !Y); \
                         E  = (!X && !Y) || (X && !Y); \
                         F  = (!X && !Y); \
                         G  = (X && !Y); 

#define DEFINE(X)   static int X, X##1;
#define UPDATE(X)   X = X##1;
#define PRINT(X)    printf(#X " = %d; ", X);

int main() {
  REGS_FOREACH(DEFINE);
  OUTS_FOREACH(DEFINE);
  while (1) { // clock
    RUN_LOGIC;
    OUTS_FOREACH(PRINT);
    REGS_FOREACH(UPDATE);
    putchar('\n');
    fflush(stdout);
    sleep(1);
  }
}
```

前端：seven-seg.py

```python
import fileinput
 
TEMPLATE = '''
\033[2J\033[1;1f
     AAAAAAAAA
    FF       BB
    FF       BB
    FF       BB
    FF       BB
    GGGGGGGGGG
   EE       CC
   EE       CC
   EE       CC
   EE       CC
    DDDDDDDDD
''' 
BLOCK = {
    0: '\033[37m░\033[0m', # STFW: ANSI Escape Code
    1: '\033[31m█\033[0m',
}
VARS = 'ABCDEFG'

for v in VARS:
    globals()[v] = 0
stdin = fileinput.input()

while True:
    exec(stdin.readline())
    pic = TEMPLATE
    for v in VARS:
        pic = pic.replace(v, BLOCK[globals()[v]]) # 'A' -> BLOCK[A], ...
    print(pic)

```

执行下：`./a.out | python seven-seg.py`

------

你还体验了 UNIX 哲学

- Make each program do one thing well
- Expect the output of every program to become the input to another

## 二、什么是程序 (源代码视角)

### 1、什么是程序？

你需要《[程序设计语言的形式语义](https://cs.nju.edu.cn/hongjin/teaching/semantics/index.htm)》

- by 梁红瑾 🎩
- λ-calculus, operational semantics, Hoare logic, separation logic
- 入围 “你在南京大学上过最牛的课是什么？” 知乎高票答案
    - ~~当然，我也厚颜无耻地入围了~~

### 2、程序就是状态机

程序就是状态机 (你在 gdb 里看到的)

- 试试程序吧 [hanoi-r.c](http://jyywiki.cn/pages/OS/2022/demos/hanoi-r.c)

汉诺塔程序，哈哈，虐人啦

hanoi-r.c

```c
void hanoi(int n, char from, char to, char via) {
  if (n == 1) printf("%c -> %c\n", from, to);
  else {
    hanoi(n - 1, from, via, to);
    hanoi(1,     from, to,  via);
    hanoi(n - 1, via,  to,  from);
  }
  return;
}
```

main.c

```c
#include <stdio.h>

#include "hanoi-r.c"

int main() {
    hanoi(3, 'A', 'B', 'c');
}
```

`#include` 的形式语义就是复制粘贴

```shell
gcc main.c
./a.out 
A -> B
A -> c
B -> c
A -> B
c -> A
c -> B
A -> B
```

------

**C 程序的状态机模型** (语义，semantics)

- 状态 = 堆 + 栈
- 初始状态 = `main` 的第一条语句
- 迁移 = 执行一条简单语句
    - 任何 C 程序都可以改写成 “非复合语句” 的 C 代码
    - [真的有这种工具](https://cil-project.github.io/cil/) (C Intermediate Language) 和[解释器](https://gitlab.com/zsaleeba/picoc)

**c语言程序是什么**？

对于c语言的程序而言，c语言的程序由很多的栈帧（stack frame）组成，每次函数调用都会产生一个新的栈帧

main 有自己的参数 argc、argv，局部变量，最重要的是程序计数器 pc，

pc 直观的看就是 gdb 中显示的条子

**函数调用是什么**？

创建一个新的状态，call 另一个函数，创建一个新的栈帧

发起调用的函数的栈帧中的 pc++；被调用的函数的栈帧中的 pc=0

**函数调用的返回是什么**？

把顶上的栈帧删掉，发起调用的函数的栈帧中的 pc--

![](./doc/Snipaste_2022-06-26_23-38-57.jpeg)

------

(这还只是 “粗浅” 的理解)

- Talk is cheap. Show me the code. (Linus Torvalds): 任何真正的理解都应该落到可以执行的代码

### 3、C 程序的语义

C 程序的状态机模型 (语义，semantics)

- 状态 = stack frame 的列表 (每个 frame 有 PC) + 全局变量
- 初始状态 = main(argc, argv), 全局变量初始化
- 迁移 = 执行 top stack frame PC 的语句; PC++
    - 函数调用 = push frame (frame.PC = 入口)
    - 函数返回 = pop frame

------

应用：将任何递归程序就地转为非递归

- 汉诺塔难不倒你 [hanoi-nr.c](http://jyywiki.cn/pages/OS/2022/demos/hanoi-nr.c)
- A → B, B → A 的也难不倒你
    - 还是一样的 `call()`，但放入不同的 `Frame`

```c
typedef struct {
  int pc, n;
  char from, to, via;
} Frame;

#define call(...) ({ *(++top) = (Frame) { .pc = 0, __VA_ARGS__ }; })
#define ret()     ({ top--; })
#define goto(loc) ({ f->pc = (loc) - 1; })

void hanoi(int n, char from, char to, char via) {
  Frame stk[64], *top = stk - 1;
  call(n, from, to, via);
  for (Frame *f; (f = top) >= stk; f->pc++) {
    switch (f->pc) {
      case 0: if (f->n == 1) { printf("%c -> %c\n", f->from, f->to); goto(4); } break;
      case 1: call(f->n - 1, f->from, f->via, f->to);   break;
      case 2: call(       1, f->from, f->to,  f->via);  break;
      case 3: call(f->n - 1, f->via,  f->to,  f->from); break;
      case 4: ret();                                    break;
      default: assert(0);
    }
  }
}
```

```c
#include <stdio.h>
#include <assert.h>

#include "hanoi-nr.c"

int main() {
    hanoi(3, 'A', 'B', 'c');
}
```

