# 真实世界的并发编程

## Overview

复习

- 并发编程的基本工具：线程库、互斥和同步

------

本次课回答的问题

- **Q**: 什么样的任务是需要并行/并发的？它们应该如何实现？

------

本次课主要内容

- 高性能计算中的并发编程
- 数据中心里的并发编程
- 我们身边的并发编程

### 一、高性能计算中的并发编程

### 1、高性能计算程序：特点

> “A technology that harnesses the power of supercomputers or computer clusters to solve complex problems requiring massive computation.” (IBM)

以计算为中心

- 系统模拟：天气预报、能源、分子生物学
- 人工智能：神经网络训练
- 矿厂：纯粹的 hash 计算
- [HPC-China 100](http://www.hpc100.cn/top100/20/)

### 2、高性能计算：主要挑战

计算任务如何分解

- 计算图需要容易并行化
    - 机器-线程两级任务分解
- 生产者-消费者解决一切
    - [MPI](https://hpc-tutorials.llnl.gov/mpi/) - “a specification for the developers and users of message passing libraries”, [OpenMP](https://www.openmp.org/) - “multi-platform shared-memory parallel programming in C/C++ and Fortran”
- [Parallel and Distributed Computation: Numerical Methods](https://web.mit.edu/dimitrib/www/pdc.html)

真正想学高性能计算的话，看完上面👆这本书就可以了

- 告诉了我们怎么去求线性方程组，线性规划这类重要的数学问题
- 模拟宏观世界就是有限元，模拟微观世界就是量子
- 在超级计算机里解决这些问题的方法就这些

------

线程间如何通信

- 通信不仅发生在节点/线程之间，还发生在任何共享内存访问
- 还记得被 [mem-ordering.c](http://jyywiki.cn/pages/OS/2022/demos/mem-ordering.c) 支配的恐惧吗？

---

高性能计算主要靠「并行化」，能够并行化的前提是这个总任务可以「分解」，子任务各自独立的跑在线程中，不过子任务可能也要进行一些交互，会涉及线程间通信

### 3、例子：Mandelbrot Set

![img](./doc/Mandelbrot.png)

- [mandelbrot.c](http://jyywiki.cn/pages/OS/2022/demos/mandelbrot.c) (embarrassingly parallel)

```c
#include "thread.h"
#include <math.h>

int NT;
#define W 6400
#define H 6400
#define IMG_FILE "mandelbrot.ppm"

static inline int belongs(int x, int y, int t) {
  return x / (W / NT) == t;
}

int x[W][H];
int volatile done = 0;

// 生成图片的算法 ppm
void display(FILE *fp, int step) { 
  static int rnd = 1;
  int w = W / step, h = H / step;
  // STFW: Portable Pixel Map
  fprintf(fp, "P6\n%d %d 255\n", w, h);
  for (int j = 0; j < H; j += step) {
    for (int i = 0; i < W; i += step) {
      int n = x[i][j];
      int r = 255 * pow((n - 80) / 800.0, 3);
      int g = 255 * pow((n - 80) / 800.0, 0.7);
      int b = 255 * pow((n - 80) / 800.0, 0.5);
      fputc(r, fp); fputc(g, fp); fputc(b, fp);
    }
  }
}

void Tworker(int tid) {
  for (int i = 0; i < W; i++)
    for (int j = 0; j < H; j++)
      if (belongs(i, j, tid - 1)) {
        double a = 0, b = 0, c, d;
        while ((c = a * a) + (d = b * b) < 4 && x[i][j]++ < 880) {
          b = 2 * a * b + j * 1024.0 / H * 8e-9 - 0.645411;
          a = c - d + i * 1024.0 / W * 8e-9 + 0.356888;
        }
      }
  done++;
}

void Tdisplay() {
  float ms = 0;
  while (1) {
    // FILE *fp = popen("viu -", "w"); assert(fp); // 没装viu的话可以注掉
    // display(fp, W / 256);
    // pclose(fp);
    if (done == NT) break;
    usleep(1000000 / 5);
    ms += 1000.0 / 5;
  }
  printf("Approximate render time: %.1lfs\n", ms / 1000);

  FILE *fp = fopen(IMG_FILE, "w"); assert(fp);
  display(fp, 2);
  fclose(fp);
}

int main(int argc, char *argv[]) {
  assert(argc == 2);
  NT = atoi(argv[1]);
  for (int i = 0; i < NT; i++) {
    create(Tworker);
  }
  create(Tdisplay);
  join();
  return 0;
}

```

```bash
$ gcc mandelbrot.c -lpthread -lm -O2

# 得安装 viu，不装的话注释掉那三行
$ ./a.out 4
Approximate render time: 8.2s

# 可以转格式打开，也可以直接打开ppm
$ convert mandelbrot.ppm a.jpg
$ open mandelbrot.ppm
```

![mandelbrot](./doc/mandelbrot-my.png)

