# 进程的地址空间

## Overview

复习

- 操作系统：加载第一个 `init` 程序，随后变为 “异常处理程序”
- `init`: fork, execve, exit 和其他系统调用创造整个操作系统世界

------

本次课回答的问题

- **Q**: 进程的地址空间是如何创建、如何更改的？

------

本次课主要内容

- 进程的地址空间和管理 (mmap)

## 一、进程的地址空间

### 1、进程的地址空间

`char *p` 可以和 `intptr_t` 互相转换

- 可以指向 “任何地方”
- 合法的地址 (可读或可写)
    - 代码 (`main`, `%rip` 会从此处取出待执行的指令)，只读
    - 数据 (`static int x`)，读写
    - 堆栈 (`int y`)，读写
    - 运行时分配的内存 (???)，读写
    - 动态链接库 (???)
- 非法的地址
    - `NULL`，导致 segmentation fault

------

它们停留在概念中，但实际呢？

```c
#include <stdio.h>

int main() {
  unsigned *p;
  p = (void *)main;

  printf("%x\n", *p);
}
```



```bash
$ gcc a.c && ./a.out
fa1e0ff3

$ objdump -d a.out
...
0000000000001149 <main>:
    1149:	f3 0f 1e fa          	endbr64 
    114d:	55                   	push   %rbp
    114e:	48 89 e5             	mov    %rsp,%rbp
...
```

指针指向不合法的地址，Segmentation fault

```c
#include <stdio.h>

int main() {
  unsigned *p;
  //p = (void *)main;
  p = (void *)(0x123123123);
  printf("%x\n", *p);
}

// Segmentation fault
```

### 2、查看进程的地址空间

pmap (1) - report memory of a process

- Claim: pmap 是通过访问 procfs (`/proc/`) 实现的
- 如何验证这一点？

------

查看进程的地址空间

- [minimal.S](http://jyywiki.cn/pages/OS/2022/demos/minimal.S) (静态链接)
- 最小的 Hello World (静态/动态链接)
    - 进程的地址空间：**若干连续的 “段”**
    - “段” 的内存可以访问
    - 不在段内/违反权限的内存访问 触发 SIGSEGV
        - gdb 可以 “越权访问”，但不能访问 “不存在” 的地址

```assembly
#include <sys/syscall.h>

.globl _start
_start:
  movq $SYS_write, %rax   # write(
  movq $1,         %rdi   #   fd=1,
  movq $st,        %rsi   #   buf=st,
  movq $(ed - st), %rdx   #   count=ed-st
  syscall                 # );

  movq $SYS_exit,  %rax   # exit(
  movq $1,         %rdi   #   status=1
  syscall                 # );

st:
  .ascii "\033[01;31mHello, OS World\033[0m\n"
ed:
```

`pmap` 查看进程所有的地址空间

```bash
$ gcc -c a.S && ld a.o && ./a.out
Hello, OS World

$ strace ./a.out
execve("./a.out", ["./a.out"], 0x7ffdea564a90 /* 22 vars */) = 0
write(1, "\33[01;31mHello, OS World\33[0m\n", 28Hello, OS World
) = 28
exit(1)                                 = ?
+++ exited with 1 +++

$ gdb a.out
(gdb) starti
Starting program: /root/demo/a.out 

Program stopped.
0x0000000000401000 in _start ()
(gdb) info inferiors
  Num  Description       Executable        
* 1    process 651134    /root/demo/a.out

$ pmap 651134
651134:   /root/demo/a.out
0000000000400000      8K r-x-- a.out
00007ffff7ffb000     12K r----   [ anon ]
00007ffff7ffe000      4K r-x--   [ anon ]
00007ffffffde000    132K rwx--   [ stack ]
ffffffffff600000      4K --x--   [ anon ]
 total              160K
```

`pmap` 的结果，由很多很多段组成

每个段有起始地址 和 大小

如：a.out 从 400000 开始有一段连续的 8K 的内存，这段内存可读可执行，这里只有代码

我们执行的第一条指令 _start 在 401000

系统里还分配了些其他空间，anon、stack

stack：操作系统在执行 execve 的时候会有些参数或环境变量，按照约定放在 stack 里面，132K，rwx

### 3、操作系统提供查看进程地址空间的机制

RTFM: `/proc/[pid]/maps` (man 5 proc)

- 进程地址空间中的每一段
    - 地址 (范围) 和权限 (rwxsp)
    - 对应的文件: offset, dev, inode, pathname
        - TFM 里有更详细的解释
- 和 readelf (-l) 里的信息互相验证
    - 课后习题：定义一些代码/数据，观察变化

```bash
$ man 5 proc

address           perms offset   dev   inode      pathname
00400000-00401000 r--p  00000000 fd:00 525733     a.out
00401000-00495000 r-xp  00001000 fd:00 525733     a.out
00495000-004bc000 r--p  00095000 fd:00 525733     a.out
004bd000-004c3000 rw-p  000bc000 fd:00 525733     a.out
004c3000-004c4000 rw-p  00000000 00:00 0          [heap]
```

---

```bash
$ strace pmap 651134 |& vim -

196 openat(AT_FDCWD, "/proc/651134/maps", O_RDONLY) = 3
197 fstat(3, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
198 read(3, "00400000-00402000 r-xp 00000000 "..., 1024) = 415
199 read(3, "", 1024)                       = 0
200 close(3)                                = 0
201 write(1, "651134:   /root/demo/a.out\n00000"..., 258651134:   /root/demo/a.out
202 0000000000400000      8K r-x-- a.out
203 00007ffff7ffb000     12K r----   [ anon ]
204 00007ffff7ffe000      4K r-x--   [ anon ]
205 00007ffffffde000    132K rwx--   [ stack ]
206 ffffffffff600000      4K --x--   [ anon ]
207  total              160K

$ cat /proc/651134/maps
00400000-00402000 r-xp 00000000 fc:01 1450381                            /root/demo/a.out
7ffff7ffb000-7ffff7ffe000 r--p 00000000 00:00 0                          [vvar]
7ffff7ffe000-7ffff7fff000 r-xp 00000000 00:00 0                          [vdso]
7ffffffde000-7ffffffff000 rwxp 00000000 00:00 0                          [stack]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]
```

`/proc/651134/maps` 有进程的编号、命令行、从属关系、地址空间的详细信息（比 pmap 更详细）

如果指针指向 rwxp 就可以写入，如果指向 r-xp 就会 Segmentation fault

---

```c
int main() {}
```

静态链接的可执行文件，地址空间是什么样的？

要比上个汇编例子多一些可执行文件 /root/demo/a.out，是因为有些段放的是变量、参数是可写的，也有代码段是不可写的

```bash
$ gcc -static a.c
$ file a.out
a.out: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=8cb7e14e1f24c623eaba46341b2ba92f11cde4cf, for GNU/Linux 3.2.0, not stripped

$ gdb a.out
(gdb) starti
(gdb) info i
  Num  Description       Executable        
* 1    process 651240    /root/demo/a.out 

$ vim /proc/651240/maps
00400000-00401000 r--p 00000000 fc:01 1450381                            /root/demo/a.out
00401000-00495000 r-xp 00001000 fc:01 1450381                            /root/demo/a.out
00495000-004bc000 r--p 00095000 fc:01 1450381                            /root/demo/a.out
004bd000-004c3000 rw-p 000bc000 fc:01 1450381                            /root/demo/a.out
004c3000-004c4000 rw-p 00000000 00:00 0                                  [heap]
7ffff7ffb000-7ffff7ffe000 r--p 00000000 00:00 0                          [vvar]
7ffff7ffe000-7ffff7fff000 r-xp 00000000 00:00 0                          [vdso]
7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]

// readelf 希望把哪些东西、多大、加载到哪里、对齐是多少
$ readelf -l a.out

Elf file type is EXEC (Executable file)
Entry point 0x401bc0
There are 10 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x0000000000000518 0x0000000000000518  R      0x1000
  LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000
                 0x00000000000936dd 0x00000000000936dd  R E    0x1000
  LOAD           0x0000000000095000 0x0000000000495000 0x0000000000495000
                 0x000000000002664d 0x000000000002664d  R      0x1000
  LOAD           0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0
                 0x0000000000005170 0x00000000000068c0  RW     0x1000
  NOTE           0x0000000000000270 0x0000000000400270 0x0000000000400270
                 0x0000000000000020 0x0000000000000020  R      0x8
  NOTE           0x0000000000000290 0x0000000000400290 0x0000000000400290
                 0x0000000000000044 0x0000000000000044  R      0x4
  TLS            0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0
                 0x0000000000000020 0x0000000000000060  R      0x8
  GNU_PROPERTY   0x0000000000000270 0x0000000000400270 0x0000000000400270
                 0x0000000000000020 0x0000000000000020  R      0x8
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x00000000000bc0c0 0x00000000004bd0c0 0x00000000004bd0c0
                 0x0000000000002f40 0x0000000000002f40  R      0x1

 Section to Segment mapping:
  Segment Sections...
   00     .note.gnu.property .note.gnu.build-id .note.ABI-tag .rela.plt 
   01     .init .plt .text __libc_freeres_fn .fini 
   02     .rodata .stapsdt.base .eh_frame .gcc_except_table 
   03     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data __libc_subfreeres __libc_IO_vtables __libc_atexit .bss __libc_freeres_ptrs 
   04     .note.gnu.property 
   05     .note.gnu.build-id .note.ABI-tag 
   06     .tdata .tbss 
   07     .note.gnu.property 
   08     
   09     .tdata .init_array .fini_array .data.rel.ro .got
```

动态链接

```bash
$ gcc a.c
$ gdb a.out
(gdb) starti
Starting program: /root/demo/a.out 

Program stopped.
0x00007ffff7fd0100 in ?? () from /lib64/ld-linux-x86-64.so.2
(gdb) info i
  Num  Description       Executable        
* 1    process 651273    /root/demo/a.out 

$ cat /proc/651273/maps
555555554000-555555555000 r--p 00000000 fc:01 1451759                    /root/demo/a.out
555555555000-555555556000 r-xp 00001000 fc:01 1451759                    /root/demo/a.out
555555556000-555555557000 r--p 00002000 fc:01 1451759                    /root/demo/a.out
555555557000-555555559000 rw-p 00002000 fc:01 1451759                    /root/demo/a.out
7ffff7fcb000-7ffff7fce000 r--p 00000000 00:00 0                          [vvar]
7ffff7fce000-7ffff7fcf000 r-xp 00000000 00:00 0                          [vdso]
7ffff7fcf000-7ffff7fd0000 r--p 00000000 fc:01 398707                     /usr/lib/x86_64-linux-gnu/ld-2.31.so
7ffff7fd0000-7ffff7ff3000 r-xp 00001000 fc:01 398707                     /usr/lib/x86_64-linux-gnu/ld-2.31.so
7ffff7ff3000-7ffff7ffb000 r--p 00024000 fc:01 398707                     /usr/lib/x86_64-linux-gnu/ld-2.31.so
7ffff7ffc000-7ffff7ffe000 rw-p 0002c000 fc:01 398707                     /usr/lib/x86_64-linux-gnu/ld-2.31.so
7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0 
7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]
```

55555555 可能每次都不一样，是因为「地址空间随机化」的机制，为了安全；调试器是一样的，为了调试方便

除此之外，还多了好多映射的区域，如：/usr/lib/x86_64-linux-gnu/ld-2.31.so

仅有一个 stack

### 4、更完整的地址空间映象

```
0000555555554000 r--p     a.out
0000555555555000 r-xp     a.out
0000555555556000 r--p     a.out
0000555555557000 r--p     a.out
0000555555558000 rw-p     a.out
00007ffff7dc1000 r--p     libc-2.31.so
00007ffff7de3000 r-xp     libc-2.31.so
00007ffff7f5b000 r--p     libc-2.31.so
00007ffff7fa9000 r--p     libc-2.31.so
00007ffff7fad000 rw-p     libc-2.31.so
00007ffff7faf000 rw-p     (这是什么？)
00007ffff7fcb000 r--p     [vvar] (这又是什么？)
00007ffff7fce000 r-xp     [vdso] (这叒是什么？)
00007ffff7fcf000 r--p     (省略相似的 ld-2.31.so)
00007ffffffde000 rw-p     [stack]
ffffffffff600000 --xp     [vsyscall] (这叕是什么？)
```

- 是不是 bss? 给我们的代码加一个大数组试试！

---

疑问：7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0 这是什么？

可读可写，不能执行，是不是未初始化的数据 bss？

来验证一下，创建个未初始化的数组数据

 ```c
 char big[1 << 30];
 
 int main() {}
 ```

0000555555559000 1048576K rw---   [ anon ] 承担了为初始化的数据

00007ffff7ffe000      4K rw---   [ anon ] 可能是库的未初始化的数据

```bash
$ gcc a.c
$ gdb a.out
(gdb) starti
Starting program: /root/demo/a.out 

Program stopped.
0x00007ffff7fd0100 in ?? () from /lib64/ld-linux-x86-64.so.2
(gdb) info i
  Num  Description       Executable        
* 1    process 651308    /root/demo/a.out  

$ pmap 651308
651308:   /root/demo/a.out
0000555555554000      4K r---- a.out
0000555555555000      4K r-x-- a.out
0000555555556000      4K r---- a.out
0000555555557000      8K rw--- a.out
0000555555559000 1048576K rw---   [ anon ]
00007ffff7fcb000     12K r----   [ anon ]
00007ffff7fce000      4K r-x--   [ anon ]
00007ffff7fcf000      4K r---- ld-2.31.so
00007ffff7fd0000    140K r-x-- ld-2.31.so
00007ffff7ff3000     32K r---- ld-2.31.so
00007ffff7ffc000      8K rw--- ld-2.31.so
00007ffff7ffe000      4K rw---   [ anon ]
00007ffffffde000    132K rw---   [ stack ]
ffffffffff600000      4K --x--   [ anon ]
 total          1048936K
```

### 5、RTFM (5 proc): 我们发现的宝藏

vdso (7): Virtual system calls: 只读的系统调用也许可以不陷入内核执行。

**无需陷入内核的系统调用**

- 例子: time (2)
    - 直接调试 [vdso.c](http://jyywiki.cn/pages/OS/2022/demos/vdso.c)
    - 时间：内核维护秒级的时间 (所有进程映射同一个页面)
- 例子: gettimeofday (2)
    - [RTFSC](https://elixir.bootlin.com/linux/latest/source/lib/vdso/gettimeofday.c#L49) (非常聪明的实现)
- 更多的例子：RTFM
    - 计算机系统里没有魔法！我们理解了进程地址空间的**全部**！

---

vdso.c

```c
#include <sys/time.h>
#include <unistd.h>
#include <stdio.h>
#include <time.h>

double gettime() {
  struct timeval t;
  gettimeofday(&t, NULL); // trapless system call
  return t.tv_sec + t.tv_usec / 1000000.0;
}

int main() {
  printf("Time stamp: %ld\n", time(NULL)); // trapless system call
  double st = gettime();
  sleep(1);
  double ed = gettime();
  printf("Time: %.6lfs\n", ed - st);
}
```

```bash
$ gcc a.c && ./a.out
Time stamp: 1658329828
Time: 1.000075s
```

