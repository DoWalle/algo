# 进程的地址空间

## Overview

复习

- 操作系统：加载第一个 `init` 程序，随后变为 “异常处理程序”
- `init`: fork, execve, exit 和其他系统调用创造整个操作系统世界

------

本次课回答的问题

- **Q**: 进程的地址空间是如何创建、如何更改的？

------

本次课主要内容

- 进程的地址空间和管理 (mmap)

## 一、进程的地址空间

### 1、进程的地址空间

`char *p` 可以和 `intptr_t` 互相转换

- 可以指向 “任何地方”
- 合法的地址 (可读或可写)
    - 代码 (`main`, `%rip` 会从此处取出待执行的指令)，只读
    - 数据 (`static int x`)，读写
    - 堆栈 (`int y`)，读写
    - 运行时分配的内存 (???)，读写
    - 动态链接库 (???)
- 非法的地址
    - `NULL`，导致 segmentation fault

------

它们停留在概念中，但实际呢？

```c
#include <stdio.h>

int main() {
  unsigned *p;
  p = (void *)main;

  printf("%x\n", *p);
}
```



```bash
$ gcc a.c && ./a.out
fa1e0ff3

$ objdump -d a.out
...
0000000000001149 <main>:
    1149:	f3 0f 1e fa          	endbr64 
    114d:	55                   	push   %rbp
    114e:	48 89 e5             	mov    %rsp,%rbp
...
```

指针指向不合法的地址，Segmentation fault

```c
#include <stdio.h>

int main() {
  unsigned *p;
  //p = (void *)main;
  p = (void *)(0x123123123);
  printf("%x\n", *p);
}

// Segmentation fault
```

### 2、查看进程的地址空间

pmap (1) - report memory of a process

- Claim: pmap 是通过访问 procfs (`/proc/`) 实现的
- 如何验证这一点？

------

查看进程的地址空间

- [minimal.S](http://jyywiki.cn/pages/OS/2022/demos/minimal.S) (静态链接)
- 最小的 Hello World (静态/动态链接)
    - 进程的地址空间：**若干连续的 “段”**
    - “段” 的内存可以访问
    - 不在段内/违反权限的内存访问 触发 SIGSEGV
        - gdb 可以 “越权访问”，但不能访问 “不存在” 的地址