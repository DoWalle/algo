# 前缀树

参考：[https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-we-esm9/](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-we-esm9/)


Trie 树（又叫前缀树或字典树）是一种用于**快速查询「某个字符串/字符前缀」是否存在**的数据结构。

其核心是使用「边」来代表有无字符，使用「点」来记录是否为「单词结尾」以及「其后续字符串的字符有哪些」。

<img src="./doc/trie.png" alt="trie" style="zoom:50%;" />

## 一、实现

### 1、TrieNode 实现

随着数据的不断插入，根据需要不断创建 TrieNode 节点。

时间复杂度：Trie 树的每次调用时间复杂度取决于入参字符串的长度。复杂度为 O(Len)。

空间复杂度：结点数量为 n，字符集大小为 k。复杂度为 O(nk)。

#### python模版

```python
class Trie(object):
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = TrieNode()

    def insert(self, word):
        """
        Inserts a word into the trie.
        :type word: str
        :rtype: None
        """
        node = self.root    # 从头节点开始查
        for c in word:
            if c not in node.children:
                node.children[c] = TrieNode()
            node = node.children[c]
        node.is_word = True # 在单词的结尾节点标记一下

    def search_prefix(self, word):
        node = self.root    # 从头节点开始查
        for c in word:
            if c not in node.children:
                return None # word中的字符没找完就断了
            node = node.children[c]
        # 返回word结尾的节点，
        # 可能是之前插入单词的结尾节点，node.is_word 为 True
        # 不是之前插入单词的结尾节点，node.is_word 为 False
        return node         

    def search(self, word):
        """
        Returns if the word is in the trie.
        :type word: str
        :rtype: bool
        """
        node = self.search_prefix(word)
        return node != None and node.is_word

    def startsWith(self, prefix):
        """
        Returns if there is any word in the trie that starts with the given prefix.
        :type prefix: str
        :rtype: bool
        """
        return self.search_prefix(prefix) != None


class TrieNode(object):
    def __init__(self):
        self.children = {}
        self.is_word = False

```

#### C++模版

```c++
class Trie {
private:
    Trie* son[26];
    bool isWord;
public:
    Trie() {
        isWord = false;
        for(int i = 0; i < 26; i++) son[i] = nullptr;
    }
    
    ~Trie(){
        for(int i = 0; i < 26 ; i++){
            if(son[i] != nullptr) delete son[i];
        }
    }

    void insert(string word) {
        Trie* root = this;
        for(char x: word){
            int cur = x - 'a';
            if(root->son[cur] == nullptr) root->son[cur] = new Trie();
            root = root->son[cur];
        }
        root->isWord = true;
    }
    
    bool search(string word) {
        Trie* root = this;
        for(char x : word){
            int cur = x - 'a';
            if(root->son[cur] == nullptr) return false;
            root = root->son[cur];
        }
        return root->isWord;
    }
    
    bool startsWith(string prefix) {
        Trie* root = this;
        for(char x : prefix){
            int cur = x - 'a';
            if(root->son[cur] == nullptr) return false;
            root = root->son[cur];
        }
        return true;
    }
};

```

### [2、二维数组实现](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-we-esm9/)

 参照原文，还有与节点实现的对比

## 二、应用

首先，在纯算法领域，前缀树算是一种较为常用的数据结构。

不过如果在工程中，**不考虑前缀匹配的话，基本上使用 hash 就能满足。**

**如果考虑前缀匹配的话，工程也不会使用 Trie 。**

一方面是字符集大小不好确定（题目只考虑 26 个字母，字符集大小限制在较小的 26 内）因此可以使用 Trie，但是工程一般兼容各种字符集，**一旦字符集大小很大的话，Trie 将会带来很大的空间浪费。**

另外，**对于个别的超长字符 Trie 会进一步变深**。

这时候如果 Trie 是存储在硬盘中，Trie 结构过深带来的影响是多次随机 IO，随机 IO 是成本很高的操作。

同时 Trie 的特殊结构，也会为分布式存储将会带来困难。

因此在工程领域中 Trie 的应用面不广。至于一些诸如「联想输入」、「模糊匹配」、「全文检索」的典型场景在工程主要是通过 ES (ElasticSearch) 解决的。而 ES 的实现则主要是依靠「倒排索引」。

