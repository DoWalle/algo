# 栈

## 一、基础

栈中存储的元素满足“后进先出（简称LIFO）”的准则。

stack 每次只能访问适配器中位于最顶端的元素，也只有移除 stack 顶部的元素之后，才能访问位于栈中的元素。

## 二、单调栈

单调栈分为「单调递增栈」和「单调递减栈」

以单调递增栈为例：

- 如果新的元素比栈顶元素大，就入栈
- 如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小，然后新元素入栈

**模版**

```c++
stack<int> st;
for(int i = 0; i < nums.size(); i++)
{
	while(!st.empty() && nums[i] < st.top())
	{
		st.pop();
	}
	st.push(nums[i]);
}
```

一般会使用加入前后哨兵的模版，有几个细节

- 在缓存数据的时候，是从左向右缓存的，
- 计算出一个结果的顺序是从右向左的（while中），并且计算完成以后我们就不再需要了，符合后进先出的特点

```c++
nums.insert(nums.begin(), 0);  // 第一个元素为添0，可以避免栈为空的情况，下面的while不用判断 !st.empty()，0可看作是所有元素中最小的值
nums.push_back(0);             // 最后一个元素添0，是为了触发最后一个单调栈开始收缩
vector<int> st = {0};          // 第一个元素0，先入栈，是为了while里面的 st.back() 第一次能取到值
for (int i = 1; i < nums.size(); i++) {
    // 此时i指向新元素，当新元素小于此时的栈顶（i-1）时，单调栈开始收缩，
    // 第一个老栈顶肯定为i-1，也是最初栈里面的最高点，否则不符合逻辑
    while (nums[i] < nums[st.back()]) {
        int curHeight = nums[st.back()];
        st.pop_back();
    }
    st.push_back(i);
}

```

