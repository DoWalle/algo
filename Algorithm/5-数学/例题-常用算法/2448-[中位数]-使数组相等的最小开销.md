题目：[2448. 使数组相等的最小开销](https://leetcode.cn/problems/minimum-cost-to-make-array-equal/)

# 方法二：中位数贪心

把 cost[i] 理解成 nums[i] 的出现次数。

根据中位数贪心，把所有数变成中位数是最优的。

详细证明参考 [462. 最小操作次数使数组元素相等 II](https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/)。

代码实现时，仍然按照方法一那样排序，然后不断累加 cost[i]，首次累加到 $\ge\dfrac{\textit{sumCost}}{2}$ 时就找到了中位数。

由于 sumCost 可能是奇数，所以要上取整，即首次累加到 $\ge\left\lceil\dfrac{\textit{sumCost}}{2}\right\rceil$ 时就找到了中位数。

```python
class Solution:
    def minCost(self, nums: List[int], cost: List[int]) -> int:
        a = zip(nums, cost)
        a = sorted(a) # zip obj 的必须使用 sorted 排序
        s = 0
        mid = (sum(cost) + 1) // 2

        target = 0
        for num, val in a:
            s += val
            if s >= mid:
                target = num
                break
        return sum(abs(target - x) * c for x, c in a)  # 把所有数变成 x
```

- 时间复杂度：O(nlog n)，其中 n 为 nums 的长度。
- 空间复杂度：O(n)