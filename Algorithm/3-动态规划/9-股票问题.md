# 股票问题

原文出处：[Most consistent ways of dealing with the series of stock problems](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems)

翻译：[股票问题系列通解（转载翻译）](https://leetcode.cn/circle/article/qiAgHn/)

股票问题一共有六道题：

- [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
- [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
- [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)
- [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)
- [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
- [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)


每个问题都有优质的题解，但是大多数题解没有建立起这些问题之间的联系，也没有给出股票问题系列的通解。这篇文章给出适用于全部股票问题的通解，以及对于每个特定问题的特解。

## 一、通用情况

首先介绍一些符号：

- 用 `n` 表示股票价格数组的长度；
- 用 `i` 表示第 `i` 天（`i` 的取值范围是 `0` 到 `n - 1`）；
- 用 `k` 表示允许的最大交易次数；

### 初步分析

假设用 `T[i][k]` 表示在第 `i` 天结束时，**最多**进行 `k` 次交易的情况下可以获得的最大收益。记录了 `[0, i]` 范围的最优解。

基础情况为  `T[i][0] = 0`，表示没有进行股票交易时没有收益

如何进行**状态转移**：第 `i` 天可能的操作有三个：**买入**、**卖出**、**休息**，通过计算得到选择每个操作可以得到的最大收益

### 通解

**但是题目或者现实世界是有限制条件的，要符合逻辑**

- 规定不能同时进行多次交易，因此如果决定在第 i 天买入，在买入之前必须持有 0 份股票，
- 如果决定在第 i 天卖出，在卖出之前必须恰好持有 1 份股票。

因此用「**第 i 天**」和「**当天结束后最多 k 次交易**」两个维度描述一个状态是不完整的

「**当天结束后持有股票的数量**」是第三个关键维度，**该因素影响第 i 天可以进行的操作，进而影响最大收益**。

因此对状态 `T` 用三个维度重新**状态定义**：

- `T[i][k][0]` 表示在第 `i` 天结束时，**最多**进行 `k` 次交易且在进行操作后持有 `0` 份股票的情况下可以获得的最大收益；
- `T[i][k][1]` 表示在第 `i` 天结束时，**最多**进行 `k` 次交易且在进行操作后持有 `1` 份股票的情况下可以获得的最大收益。

> 每次交易包含成对的操作：「买入」和「卖出」，仅当「买入」时会增加交易次数，一次交易应该被理解为一次「交易周期」，买入会增加一次交易周期，而「卖出」只是将这次交易周期「闭环」，实际不会增加交易周期的次数

**状态转移方程**：

```c++
T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])
T[i][k][1] = max(T[i - 1][k][1], T[i - 1][k - 1][0] - prices[i])
```

- `T[i][k][0]`，当前结束后持有的股票为 `0` 个，因此当天仅可进行「休息」和「卖出」操作，取两种操作的最大值
  - 当天「休息」，`T[i - 1][k][0]`
  - 当天「卖出」，`T[i - 1][k][1] + prices[i]`，股票持有数从前一天的 `1` 减少到当前的 `0`，由于是卖出操作不会影响到交易周期的次数，因此 `k` 不变，最后收益增加 `prices[i]`

- `T[i][k][1]`，当前结束后持有的股票为 `1` 个，因此当天仅可进行「休息」和「买入」操作，取两种操作的最大值
  - 当天「休息」，`T[i - 1][k][1]`
  - 当天「买入」，`T[i - 1][k - 1][0] - prices[i]`，股票持有数从前一天的 `0` 增加到当前的 `1`，由于是买入操作交易周期数从前一天的 `k-1` 次增加到当前的 `k` 次，最后收益减少 `prices[i]`

**base case**：

- `T[i][0][0] = 0` 表示没有进行股票交易时没有收益
- `T[i][0][1] = INT_MIN` 的含义是在没有进行股票交易时不允许持有股票

**获取答案**：

为了得到最后一天结束时的最大收益，遍历股票价格数组，根据状态转移方程计算 `T[i][k][0]` 和 `T[i][k][1]` 的值。

最终答案是 `T[n - 1][k][0]`，即 `n - 1` 天时，最多进行了 `k` 次交易，持有的股票数清 `0` 后的最大收益。

因为结束时持有 `0` 份股票的收益一定大于持有 `1` 份股票的收益。

## 二、实际情况分类

上述六个股票问题是根据 `k` 的值进行分类的，其中 `k` 是允许的最大交易次数。最后两个问题有附加限制，包括「冷冻期」和「手续费」。通解可以应用于每个股票问题。

### 1、最多进行一次交易 k=1

对应的题目是「[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)」

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示：**

- `1 <= prices.length <= 10^5`
- `0 <= prices[i] <= 10^4`

---

题目没有说哪天不能交易（即第 `i` 天 `k` 必须为 `0`），每天最多都会进行一次交易（每天的 `k` 都 `1`）

因此将「当天最多交易次数 `k` 」这个维度消除掉

**1. 定义状态**

- `T[i][0]` 第 i 天，当天结束后，持有股票数为 0 的最大利润（`[0, i]` 范围的最优解）
- `T[i][1]` 第 i 天，当天结束后，持有股票数为 1 的最大利润（`[0, i]` 范围的最优解）

**2. 状态转移方程**

```c++
T[i][0] = max(T[i - 1][0], T[i - 1][1] + prices[i])
T[i][1] = max(T[i - 1][1], 0 - prices[i])
```

- `T[i][0]`，当前结束后持有的股票为 `0` 个，因此当天仅可进行「休息」和「卖出」操作，取两种操作的最大值
  - 当天「休息」，`T[i - 1][0]`
  - 当天「卖出」，`T[i - 1][1] + prices[i]`，股票持有数从前一天的 `1` 减少到当前的 `0`，最后收益增加 `prices[i]`

- `T[i][1]`，当前结束后持有的股票为 `1` 个，因此当天仅可进行「休息」和「买入」操作，取两种操作的最大值
  - 当天「休息」，`T[i - 1][1]`
  - 当天「买入」，`0 - prices[i]`，收益减少 `prices[i]`

问：这里为什么是用 `0` 减而不是 `T[i-1][0]` ?

答：本题目要求，只能进行一次交易周期

- 因此在当天买入前不能进行交易，前一天的最大收益必然为 `0`
- `T[i-1][0]` 代表了第 `i - 1` 天结束后，持有股票数为 `0`，其中包含了前面的 `i-1` 天可能进行过交易的情况
- 如果真要用状态来计算的话，应该使用 `T[i-1][0][0]`，第 `i - 1` 天最大的交易次数为 `0` 次（不能交易）且持有股票数为 `0`
- 而交易次数这个维度已经被消除掉了，故直接用 0 表示前面那些天不能交易的最大收益

**3. 初始化**

第 0 天的时候休息：`T[0][0] = 0`

第 0 天的时候买入：`T[0][1] = -prices[i]`

**4. 输出**

`T[n-1][0]` 第 n-1 天，当天结束后，持有股票数为 0 的最大利润（肯定比最后一天手上还有股票的情况好）

**空间优化**

仅和前一天有关，可优化

**复杂度分析**

时间复杂度：`O(n)`

空间复杂度：`O(n)` 或 `O(1)`

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));

        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);  // 当天 休息 或 卖
            dp[i][1] = max(dp[i - 1][1], -prices[i]);                // 当天 休息 或 买
        }
        return dp[n - 1][0];
    }
};
```



```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();

        int pre_zero = 0;
        int pre_one = -prices[0];

        for (int i = 1; i < n; i++) {
            int cur_zero = max(pre_zero, pre_one + prices[i]);  // 当天 休息 或 卖
            int cur_one = max(pre_one, -prices[i]);             // 当天 休息 或 买
            pre_zero = cur_zero;
            pre_one = cur_one;
        }
        return pre_zero;
    }
};
```

