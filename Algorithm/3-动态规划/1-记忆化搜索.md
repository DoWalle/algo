# 记忆化搜索

参考：[记忆化搜索](https://oi-wiki.org/dp/memo/)

## 记忆化搜索与动态规划的关系

记忆化搜索是一种通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式。

因为记忆化搜索确保了每个状态只访问一次，它也是一种常见的动态规划实现方式。

见动态规划基础中[两个例子（带备忘录递归实现）](./0-动态规划基础.md)

### 方法一

1. 把这道题的 dp 状态和方程写出来
2. 根据它们写出 dfs 函数
3. 添加记忆化数组

### 方法二

1. 写出这道题的暴搜程序，最好是 dfs
2. 将这个 dfs 改成「无需外部变量」的 dfs
3. 添加记忆化数组

## 思路

- 具备「最优子结构」
- 具备「重叠子问题」，不具备则进行普通递归
- 如何定义 memo

## 模版

```c++
int dfs(vector<int>& memo, int n) {
    if (n == 1 || n == 2) return 1;    // base case
    if (memo[n] != 0) return memo[n];  // 已经计算过

    int res = 0;
    for (下个节点) {
        res = max(res, dfs(memo, next_node));
    }
    memo[n] = res;  // 记录已算过的结果
    return memo[n];
}

int main(int N) {
    vector<int> memo(N + 1, 0);
    return dfs(memo, N);
}
```

