题目：[322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

## 方法一：常规解法（超时）

**167 / 188** 个通过测试用例

时间复杂度：`O(N*C*C)`

空间复杂度：`O(C*C)`

```c++
class Solution {
public:
    int INF = INT_MAX;  // 表示无法组成指定金额

    int coinChange(vector<int>& coins, int amount) {
        // amount 相当于背包容量
        // coins 相当于每个物品的体积
        // 每个物品对结果的贡献都是 1
        int n = coins.size();

        // dp[i][w] 表示[0,i]范围的硬币组成金额「巧合」为w的最少硬币数
        vector<vector<int>> dp(n, vector<int>(amount + 1, 0));

        // 预处理第一个硬币
        for (int w = 0; w <= amount; w++) {
            int k = w / coins[0];
            if (k * coins[0] == w) {
                dp[0][w] = k;
            } else {
                dp[0][w] = INF;
            }
        }

        for (int i = 1; i < n; i++) {
            for (int w = 0; w <= amount; w++) {
                // 不选当前硬币
                int no = dp[i - 1][w];
                // 选当前硬币
                int yes = INT_MAX;
                for (int k = 1; w - k * coins[i] >= 0; k++) {
                    if (dp[i - 1][w - k * coins[i]] != INF) {
                        yes = min(yes, dp[i - 1][w - k * coins[i]] + k);
                    }
                }
                dp[i][w] = min(no, yes);
            }
        }

        return dp[n - 1][amount] == INF ? -1 : dp[n - 1][amount];
    }
};
```

## 方法二：一维解法

容量维度「从小到达遍历」
$$
dp[w] = min(dp[w], \ dp[w-wt[i]]+1)
$$
为啥是 +1 ？

因为这道题的价值数组其实是 val = [1,1,1,1,1...] ，**因为每个硬币被选曲后对于背包的共享量都是 1**

时间复杂度：`O(N*C)`

空间复杂度：`O(C)`

```c++
class Solution {
public:
    int INF = INT_MAX;  // 表示无法组成指定金额

    int coinChange(vector<int>& coins, int amount) {
        // amount 相当于背包容量
        // coins 相当于每个物品的体积
        // 每个物品对结果的贡献都是 1
        int n = coins.size();

        vector<int> dp(amount + 1, 0);

        // 预处理第一个硬币
        for (int w = 0; w <= amount; w++) {
            int k = w / coins[0];
            if (k * coins[0] == w) {
                dp[w] = k;
            } else {
                dp[w] = INF;
            }
        }

        for (int i = 1; i < n; i++) {
            for (int w = 0; w <= amount; w++) {
                // 1、此时内涵了不选当前硬币 dp[w] = dp[w]
                // 2、选当前硬币
                if (w - coins[i] >= 0 && dp[w - coins[i]] != INF) {
                    dp[w] = min(dp[w], dp[w - coins[i]] + 1);
                }
            }
        }

        return dp[amount] == INF ? -1 : dp[amount];
    }
};
```

