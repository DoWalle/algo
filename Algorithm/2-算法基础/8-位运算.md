# 位运算

## 一、应用

### 1、判断奇偶 num & 1

偶数的二进制的末尾 为0，奇数的二进制的末尾 为1

按位与 & 将参与运算的两操作数各对应的二进制位进行与操作，位数不够的数自动在前面补 0

- 偶数：原数的二进制末尾为0，与1进行按位与，结果为0，`(finalSum & 1) == 0`
- 奇数：原数的二进制末尾为1，与1进行按位与，结果为1，`(finalSum & 1) == 1`

注意最好不要去判断 `i & 1 == 0`，这样会有问题（虽然不知道为啥产生）

```c++
#include <iostream>
using namespace std;
int main() {
    for (int i = 0; i < 5; i++) {
        if (i & 1) {
            cout << i << ", " << (i & 1) << endl;  // 奇数
        } else {
            cout << i << ", " << (i & 1) << endl;  // 偶数
        }
    }
    // 0, 0
    // 1, 1
    // 2, 0
    // 3, 1
    // 4, 0
    return 0;
}
```

### 2、除2 num >> 1

注意：结果是向下取整

```c++
#include <iostream>
using namespace std;
int main() {
    cout << (1 >> 1) << endl;  // 0
    cout << (2 >> 1) << endl;  // 1
    cout << (3 >> 1) << endl;  // 1
    cout << (4 >> 1) << endl;  // 2
    cout << (5 >> 1) << endl;  // 2
    return 0;
}
```

### 3、乘2 num << 1

num << 1，相当于 num 乘以 2

```c++
#include <iostream>
using namespace std;
int main() {
    cout << (1 << 1) << endl;   // 2
    cout << (2 << 1) << endl;   // 4
    cout << (3 << 1) << endl;   // 5
    cout << (10 << 1) << endl;  // 20
    cout << (23 << 1) << endl;  // 46
    return 0;
}
```

### 4、2的 num 次方 1 << num

```c++
#include <iostream>
using namespace std;
int main() {
    cout << (1 << 1) << endl;   // 2
    cout << (1 << 2) << endl;   // 4
    cout << (1 << 3) << endl;   // 8
    cout << (1 << 10) << endl;  // 1024
    cout << (1 << 22) << endl;  // 4194304
    return 0;
}
```

### 5、求中值 l + ((r - l) >> 1)

```c++
mid = (l + r) >> 1;
mid = l + ((r - l) >> 1); // 可防止越界，推荐使用，注意位运算符的优先级低
```

### 6、两个数的平均数 (a & b)+((a ^ b) >> 1)

```c++
#include <iostream>
using namespace std;

int average(int a, int b) {
    return (a & b) + ((a ^ b) >> 1);
}

int main() {
    cout << average(3, 10) << endl;  // 6
    return 0;
}
```

### 7、不使用第三个变量的情况下交换两个变量的值

原理：运用异或的特性 a ^ b = c --> c ^ a = b --> c ^ b = a

```c++
#include <iostream>
using namespace std;

void exchange(int &a, int &b) {
    a = a ^ b;
    b = a ^ b;  // 相当于：a0 ^ b0 ^ b0 = a0
    a = a ^ b;  // 相当于：a0 ^ b0 ^ a0 ^ b0 ^ b0 = b0
}

int main() {
    int a = 3;
    int b = 5;
    exchange(a, b);
    cout << a << endl;  // 5
    cout << b << endl;  // 3
    return 0;
}
```

### 8、不用加减乘除做加法

- step1：异或查看两个数进行加法操作后的结果
- step2：与运算计算出想对应的位置的进位结果，然后左移一位

```c++
#include <iostream>
using namespace std;

int add1(int a, int b) {
    while (b != 0) {
        int tmp = a ^ b;   // 计算出相对应的位置相加后的结果
        b = (a & b) << 1;  // 计算出想对应的位置的进位，然后左移一位
        a = tmp;
    }
    return a;
}
// b代表的是两数相加是否有进位，有的话就继续，没有的话就结束得出相加后的答案

// 简写
int add(int a, int b) {
    return (a ^ b) + ((a & b) << 1);
}

int main() {
    cout << add1(3, 5) << endl;  // 8
    cout << add(2, 4) << endl;   // 6
    return 0;
}
```

### 9、二进制中1的个数

```c++
#include <iostream>
using namespace std;

int getCnt(int num) {
    if (num == 0 || num == 1) {
        return num;
    }
    int cnt = 0;
    while (num != 0) {
        cnt++;
        num = num & (num - 1);
    }
    return cnt;
}

int main() {
    int n = 5;                  // 5 的二进位为 101
    cout << getCnt(n) << endl;  // 2
    return 0;
}
```



## 二、异或 XOR

参考 1：[神级运算——位运算](https://zhuanlan.zhihu.com/p/102277869)

参考 2：[异或有什么用？](https://www.zhihu.com/question/374105353)

【异或】是一个重要的逻辑运算，具体到位运算，相同位异或得0，不同位异或得1，

相当于每个位置按二进制计算方式相加

公式为：

```python
a ^ b = (a & ~b) | (~a & b)
```

### 1、运算规律

归零律：**两个数相同，这两个数异或为 0**

```python
a = b -> a ^ b = 0
a ^ a = 0

4 ^ 4 = 0
```

交换律：

```python
a ^ b = b ^ a
```

结合律：

```python
a ^ b ^ c = (a ^ b) ^ c = (a ^ b) ^ c
```

自反性：连续和同一个因子做异或运算异或运算，最终结果为自己

```python
a ^ b ^ b = a ^ 0 = a
b ^ a ^ b = a

4 ^ 3 ^ 4 = 3
```

异或的运算法则：

```python
a ^ b = c
b ^ a = c

c ^ a = b
c ^ b = a

a ^ c = b
b ^ c = a

3 ^ 4 = 7
4 ^ 3 = 7

7 ^ 3 = 4
7 ^ 4 = 3

3 ^ 7 = 4
4 ^ 7 = 3
```

### 2、推论

由a^b=(a&~b)|(~a&b)公式，还可得到，

- 当b=全1时，a^b=(a&全0)|(~a&全1)=~a，此时【异或】相当于对a取反（不能直接异或十进制 1）
- 当b=全0时，a^b=(a&全1)|(~a&全0)=a，此时【异或】结果就等于a（任何数异或十进制 0，还是本身）

由归零律，可以用异或交的两个不同位置的变量x,y：

- y=x^y，此时y=x^y，x值不变；
- x=y^x，此时x=(x^y)^x=y，y=x^y；
- y=y^x，此时y=(x^y)^y=x，x=y，交换完毕；

## 三、滚动数组

**在状态转移的过程中计算「某一行」的时候，只需要依赖「前一行」**

因此可以用一个只有两行的数组来存储中间结果，根据当前计算的行号是偶数还是奇数来交替使用第 0 行和第 1 行。

```
偶数 0 2 4

奇数 1 3 5
```

这样的空间优化方法称为「**滚动数组**」，**天然的将 cur 和 pre 的转移与奇偶变化相结合**

这种空间优化方法十分推荐，因为改动起来没有任何思维难度。

只需要将代表行的维度修改成 2，并将所有使用行维度的地方从 `i` 改成 `i%2` 或者 `i&1` 即可

例如：申请状态数组 `dp[2]`

```
初始化第 0 行
将 dp[0 & 1] = dp[0] 进行记录

计算第 1 行，依赖第 0 行
dp[1 & 1] = dp[1]，从 dp[(1-1) & 1] = dp[0] 获取前一行信息

计算第 2 行，依赖第 1 行
dp[2 & 1] = dp[0]，从 dp[(2-1) & 1] = dp[1] 获取前一行信息

计算第 i 行，依赖第 i-1 行
dp[i & 1] = dp[a]，从 dp[(i-1) & 1] = dp[b] 获取前一行信息

i 为偶数 a = 0，b = 1
i 为奇数 a = 1，b = 0
```

## 四、状态压缩

**使用一个二进制数记录当前哪些数已被选，哪些数未被选，目的是为了可以使用位运算进行加速**

**应用：状态压缩可用在 dfs、bfs、dp 中，将状态维度从 n 维降至 1 维**

**注意：n 不能太大，一般是 15 以下**

```
例如一串二进制数 000...01010

代表值为 1 和值为 3 的数字已经被使用了，而值为 0、2 的节点尚未被使用。
```

「状态压缩」的一些基本的操作：有 `n` 个节点，变量 `state` 存放了「当前节点的使用情况」

- 总的 state 数量：`1 << n`，一个节点对应了选或不选，所以有 2^n 种可能
- 记录 num 用过了：`state = (1 << num) | state`
-  判断 num 有没有用过：`((state >> num) & 1) == 0`，等于 0 没用过，大于 0 用过，`(1 << num) & state) == 0` 也行，但前者更好理解
- 查看选择 num 之前的 state：`state & (~(1 << num))`
- 判断当前 state 是否将所有的节点都走过：`state == (1 << n) - 1`

```c++
#include <iostream>
#include <string>
#include <vector>

using namespace std;

string dec_to_bin(int dec) {
    vector<int> binL;
    while (dec != 0) {
        binL.push_back(dec % 2);
        dec = dec / 2;
    }
    // 结果是逆序的，需要反过来
    reverse(binL.begin(), binL.end());

    string bin;
    for (int b : binL) {
        bin += b + 48;
    }
    return bin;
}

int main() {
    int state = 0;  // 记录用过的数，初始时为0
    int n = 4;      // 有 4 个节点

    cout << (1 << n) << endl;  // 16 种可能

    int idx = 2;
    cout << ((1 << idx) & state) << endl;  // 检查 节点2 有没有被用过，0 没有
    state = (1 << idx) | state;            // 将 节点2 记录在 state 这个数中，传递下去
    cout << dec_to_bin(state) << endl;     // 100
    cout << ((state >> idx) & 1) << endl;  // 检查 节点2 有没有被用过，1 用过

    idx = 3;
    cout << ((state >> idx) & 1) << endl;  // 检查 节点3 有没有被用过，0 没有
    state = (1 << idx) | state;            // 将 节点4 记录在 state 这个数中，传递下去
    cout << dec_to_bin(state) << endl;     // 1100

    int pre = state & (~(1 << idx));  // 查看记录 节点3 之前的 state
    cout << dec_to_bin(pre) << endl;  // 100

    idx = 1;
    state = (1 << idx) | state;  // 将 节点1 记录在 state 这个数中，传递下去
    idx = 0;
    state = (1 << idx) | state;         // 将 节点0 记录在 state 这个数中，传递下去
    cout << dec_to_bin(state) << endl;  // 1111

    cout << dec_to_bin((1 << n) - 1) << endl;  // 1111

    return 0;
}

```

