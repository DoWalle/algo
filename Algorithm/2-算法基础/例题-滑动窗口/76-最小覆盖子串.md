#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        sz = len(s)
        need = collections.defaultdict(int)     # 需要凑齐的数
        for c in t:
            need[c] += 1
        window = collections.defaultdict(int)   # 「窗口」中的相应字符的出现次数
        match = 0               # 当前窗口中匹配到的字符数
        need_match = len(need)  # 所需匹配的字符数
        min_length = sz         # 记录最小串的长度

        l = 0
        r = 0
        ans = ""
        while r < sz:
            if s[r] in need:
                window[s[r]] += 1
                if window[s[r]] == need[s[r]]:  # 通过移动右指针，使窗口有所有需要字符
                    match += 1                  # 每匹配到到一个字符，当前匹配字符数加1
                
                while match == need_match:      # 相等时，窗口里有所有匹配到的字符，下面移动左指针
                    cur_length = r - l          # 此时窗口的长度
                    if cur_length < min_length: # 如果最小窗口长度大于此时窗口长度
                        ans = s[l:r+1]
                        min_length = cur_length
                    if s[l] in need:            # 移动左窗口，抛出一个值，以此寻找更小的长度
                        window[s[l]] -= 1       # 减少窗口里的字符统计
                        if window[s[l]] < need[s[l]]: # 当窗口里的字符统计数小于所需要的字符统计数时
                            match -= 1          # 减少一个匹配数
                    l += 1
            r += 1
        return ans
```

