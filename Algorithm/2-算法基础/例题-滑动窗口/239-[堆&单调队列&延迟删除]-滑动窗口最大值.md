#### [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

**[方法一：优先队列](https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/)**

**本题的亮点：**

**窗口内的数量不一定要维护成题目给的 k 长度，也不一定都满足条件**

而是在遍历的时候，若是发现最大值不在所谓的窗口内时去掉

因为本题只关注最大值，比最大值小的那些值在不在窗口内不用关心

- 时间复杂度：O(nlog⁡n) ，其中将一个元素放入优先队列的时间复杂度为 O(log⁡n)

- 空间复杂度：O(n)，即为优先队列需要使用的空间

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:

        sz = len(nums)
        # 通过负值实现大根堆，第一个值存值，第二个值存下标
        window = [(-nums[i], i) for i in range(k)]
        heapq.heapify(window)
        right = k
        ans = [-window[0][0]]

        while right < sz:
            heapq.heappush(window, (-nums[right], right))

            while window[0][1] <= right - k:    # 精髓
                # 如果窗口内的最大值，不在下标的 k 范围内，直到这个最大值在范围内
                heapq.heappop(window)
            ans.append(-window[0][0])
            
            right += 1
        return ans
```

**[方法二：单调队列](https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/)**

我们可以使用一个队列存储所有还没有被移除的下标。

在队列中，这些下标按照从小到大的顺序被存储，与在nums中的顺序保持一致

**并且它们在数组 nums 中对应的值是严格单调递减的，为了O(1)拿到最大和最小值**

当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较。**如果新元素大于等于队尾元素，那么队尾元素就可以被永久地移除。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。以此来维护队列单调递减**

此时队首下标对应的元素就是滑动窗口中的最大值。与方法一中相同的是，此时的最大值可能在滑动窗口左边界的左侧，并且随着窗口向右移动，它永远不可能出现在滑动窗口中了。**因此我们还需要不断从队首弹出已经不在窗口内的最大元素，直到队首元素在窗口中为止。**

为了可以同时弹出队首和队尾的元素，我们需要使用**双端队列**。满足这种单调性的双端队列一般称作**「单调队列」**。

- 时间复杂度：O(n) 每一个下标恰好被放入队列一次，并且最多被弹出队列一次

- 空间复杂度：O(k) 使用的数据结构是双向的，因此「不断从队首弹出元素」保证了队列中最多不会有超过 k+1 个元素

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:

        sz = len(nums)
        right = k
        window = collections.deque()
        for i in range(k):
            while window and nums[i] >= nums[window[-1]]:
                # 如果前者大于当前的值，就把前者移出去，保障队列是单调递减的
                window.pop()
            window.append(i)

        ans = [nums[window[0]]]
        while right < sz:
            while window and nums[right] >= nums[window[-1]]:
                # 保障队列是单调递减的
                window.pop()
            window.append(right)

            while window[0] <= right - k:
                # 每往前走一个，保障队列里的第一个一定是窗口内的最大值
                window.popleft()
            ans.append(nums[window[0]])

            right += 1
        return ans
```

