#### [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        visited = set()
        for n in nums:
            if n in visited:
                return True
            visited.add(n)
        return False
```

#### [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

滑动窗口

```python
class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        sz = len(nums)
        left = 0
        right = 0
        window = collections.defaultdict(int)

        while right < sz:
            window[nums[right]] += 1
            if window[nums[right]] == 2:
                return True
            while right - left == k:
                window[nums[left]] -= 1
                left += 1
            right += 1
        return False
```

#### [220. 存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/)

[红黑树：](https://leetcode-cn.com/problems/contains-duplicate-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-dlnv/)

根据题意，对于任意一个位置 i（假设其值为 u），我们其实是希望在下标范围为 [max(0,i−k),i) 内找到值范围在 [u−t,u+t] 的数。

一个朴素的想法是每次遍历到任意位置 i 的时候，往后检查 k 个元素，但这样做的复杂度是 O(nk) 的，会超时。

显然我们需要优化「检查后面 k 个元素」这一过程。

我们希望使用一个「有序集合」去维护长度为 k 的滑动窗口内的数，该数据结构最好支持高效「查询」与「插入/删除」操作：

1. 或许你会想到近似 O(1 操作的 HashMap，但注意这里我们需要找的是符合 abs(nums[i],nums[j])⩽t 的两个值，nums[i] 与 nums[j] 并不一定相等，而 HashMap 无法很好的支持「范围查询」操作。
2. 例如 AVL，能够让我们在最坏为 O(logk) 的复杂度内取得到最接近 u 的值是多少，但本题除了「查询」以外，还涉及频繁的「插入/删除」操作（随着我们遍历 nums 的元素，滑动窗口不断右移，我们需要不断的往「有序集合」中删除和添加元素）。简单采用 AVL 树，会导致每次的插入删除操作都触发 AVL 的平衡调整，一次平衡调整会伴随着若干次的旋转。

而红黑树则很好解决了上述问题：将平衡调整引发的旋转的次数从「若干次」限制到「最多三次」。**因此，当「查询」动作和「插入/删除」动作频率相当时，更好的选择是使用「红黑树」**

时间复杂度：基于红黑树，查找和插入都是 O(logk) 复杂度。整体复杂度为 O(nlogk)

空间复杂度：O(k)

```python
class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:
        from sortedcontainers import SortedList
        window = SortedList()
        sz = len(nums)
        left = 0
        right = 0

        if k == 0 or sz in (0, 1):
            return False
            
        while right < sz:
            window.add(nums[right])
            if right == 0: # 如果是第一个就跳过
                right += 1
                continue
            idx = window.bisect_left(nums[right]) # 在窗口内的排序
            if idx > 0 and abs(window[idx] - window[idx-1]) <= t:
                # 如果待测值在窗口内不排在第一位（最小值），向左找
                # 并且待测值在窗口内的排序的前一位，是小于等于待测值的最大值，
                # 取这两个值的绝对值于 t 相比较
                # 因为如果最相近的值都不满足 小于等于t 的条件，那么其他值也不能可能满足
                return True
            if idx < len(window) - 1 and abs(window[idx+1] - window[idx]) <= t:
                # 如果待测值在窗口内不排在最后一位（最大值），向左找
                return True
            
            if right >= k:
                window.remove(nums[left])
                left += 1
            
            right += 1
        return False
```

[桶排序：](https://leetcode-cn.com/problems/contains-duplicate-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-dlnv/)

**不会**

时间复杂度：O(n)

空间复杂度：O(k)
