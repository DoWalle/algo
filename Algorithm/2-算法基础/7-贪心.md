# 贪心

什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。

比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。

什么是贪心选择性质呢，简单说就是：**每一步都做出一个局部最优的选择，最终的结果就是全局最优**。注意哦，这是一种特殊性质，其实**只有一小部分问题拥有这个性质**。

比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。

然而，大部分问题都明显不具有贪心选择性质。比如打斗地主，对手出对儿三，按照贪心策略，你应该出尽可能小的牌刚好压制住对方，但现实情况我们甚至可能会出王炸。这种情况就不能用贪心算法，而得使用动态规划解决，参见前文 [动态规划解决博弈问题](http://mp.weixin.qq.com/s?__biz=MzU0MDg5OTYyOQ==&mid=2247484266&idx=1&sn=72bc8c3e4b026e2f08905e139a245c53&chksm=fb336328cc44ea3e77b4ad0bd36d4a0d2e7009f9c3597f38b6ba93620a98b302524be4e87d08&scene=21#wechat_redirect)。

## 一、场景

### 0、排序预处理

通过排序，将优先选择的元素放到前面

数组中的元素为数对，还涉及排序的，有下面的场景

- 以末尾边界作为高优先级排序
- 第一个元素正向排序，根据第二个元素反向排序
- 第一个元素反向排序，根据第二个元素正向排序

### 1、区间调度问题（排序+贪心）

一个很经典的贪心算法问题 Interval Scheduling（区间调度问题）

给你很多形如`[start,end]`的闭区间，请你设计一个算法，**算出这些区间中「最多」有几个互不相交的区间**。

举个例子，`intvs=[[1,3],[2,4],[3,6]]`，这些区间最多有两个区间互不相交，即`[[1,3],[3,6]]`

这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间`[start,end]`表示开始和结束的时间，请问你今天「最多」能参加几个活动呢？

**思路**:

1. 从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中**结束最早的**（end 最小）。
2. 把所有与 x 区间相交的区间从区间集合 intvs 中删除。
3. 重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。

**算法实现**:

<img src="./doc/tanxin-1.png" alt="tanxin-1" style="zoom:50%;" />

1. 预先**按照 end 排序**，方便选取最小的 end
2. 当前 end 与 下一个 start 比较，**选出第一个「大于等于」end 的 start**
3. 记录答案，并**将 end 更新为选出 start 区间的那个 end**

```c++
#include <algorithm>  // sort()
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<vector<int>> intervals = {{1, 3}, {3, 6}, {2, 4}};
    auto cmp = [&](const vector<int> &a, const vector<int> &b) -> bool {
        return a[1] < b[1];
    };
    sort(intervals.begin(), intervals.end(), cmp);

    int cnt = 1;                // 默认有第一个区间
    int end = intervals[0][1];  // 默认第一个区间的end
    for (vector<int> intv : intervals) {
        if (intv[0] >= end) {
            cnt++;
            end = intv[1];
        }
    }
    cout << cnt << endl;  // 2
    return 0;
}
```

### 2、跳跃问题

[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**思路**：

- 最初位于数组的 **第一个下标** ，开始时位于下标为 0 的位置，**最远可走的位置（全局最优）初始化为 farthest = 0**
- 首先，当前位置和全局最优的最远位置 farthest 做对比，看当前位置能不能走到。如果当前位置超过最远位置返回false
- 然后每一步都计算一下从**当前位置最远能够跳到哪里**，更新 farthest

通过每一步的最优解，更新全局最优解，这就是贪心

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int farthest = 0;
        for (int i = 0; i < n; i++) {
            if (i > farthest) {
                return false;
            }
            farthest = max(farthest, i + nums[i]);
        }
        return true;
    }
};
```

[45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

题解：[45-[跳跃问题-bfs]-跳跃游戏II](./例题-贪心/45-[跳跃问题-bfs]-跳跃游戏II.md)
