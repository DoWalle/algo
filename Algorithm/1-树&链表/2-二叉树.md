# 二叉树

## 一、遍历

<img src="./doc/二叉树.png" style="zoom:50%;" />

- 前序遍历（中左右）：5 4 1 2 6 7 8
- 中序遍历（左中右）：1 4 2 5 7 6 8
- 后序遍历（左右中）：1 2 4 7 8 6 5
- 层序遍历：5 4 6 1 2 7 8

### 1、前序遍历

```c++
class Solution {
public:
    void dfs(TreeNode *cur, vector<int> &vec) {
        if (cur == NULL) return;
        vec.push_back(cur->val);  // 中
        dfs(cur->left, vec);      // 左
        dfs(cur->right, vec);     // 右
    }
    vector<int> preorderTraversal(TreeNode *root) {
        vector<int> res;
        dfs(root, res);
        return res;
    }
};
```

### 2、中序遍历

```c++
class Solution {
public:
    void dfs(TreeNode *cur, vector<int> &vec) {
        if (cur == NULL) return;
        dfs(cur->left, vec);
        vec.push_back(cur->val);
        dfs(cur->right, vec);
    }

    vector<int> inorderTraversal(TreeNode *root) {
        vector<int> res;
        dfs(root, res);
        return res;
    }
};
```

### 3、后序遍历

```c++
class Solution {
public:
    void dfs(TreeNode *cur, vector<int> &vec) {
        if (cur == NULL) return;
        dfs(cur->left, vec);
        dfs(cur->right, vec);
        vec.push_back(cur->val);
    }

    vector<int> postorderTraversal(TreeNode *root) {
        vector<int> res;
        dfs(root, res);
        return res;
    }
};
```

### 4、层序遍历

每一层放入一个 vector 写法，如：[[3],[9,20],[15,7]]

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode *root) {
        vector<vector<int>> res;
        if (!root) return res;

        queue<TreeNode *> q;
        q.push(root);
        while (!q.empty()) {
            int layerSz = q.size();
            vector<int> layer;
            for (int i = 0; i < layerSz; i++) {
                auto node = q.front();
                q.pop();
                layer.push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
            res.push_back(layer);
        }
        return res;
    }
};
```

全部放一起，如：[3 9 20 15 7 ]

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode *root) {
        vector<int> res;
        queue<TreeNode *> q;
        q.push(root);
        while (!q.empty()) {
            auto node = q.front();
            q.pop();
            res.push_back(node->val);
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        for (const auto &c : res) cout << c << " ";
        return res;
    }
};
```



## 二、树的恢复

#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

1、题目告诉我们没有重复的元素，才可以用 inorderIdx 记录其中节点的index

2、Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]

 	如果输入中有 None 来标记没有节点了，那么就可以通过一个前序就能恢复

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        # 先序遍历的顺序是根节点，左子树，右子树。中序遍历的顺序是左子树，根节点，右子树。
        # 所以我们只需要根据先序遍历得到根节点，然后在中序遍历中找到根节点的位置，它的左边就是左子树的节点，右边就是右子树的节点。
        # 生成左子树和右子树就可以递归的进行了。
        inorderIdx = collections.defaultdict(int)
        for i, v in enumerate(inorder):
            inorderIdx[v] = i

        def dfs(preStart, preEnd, inStart, inEnd):
            # preStart  指向前序的起点
            # preEnd    指向前序的终点
            # inStart   指向中序的起点
            # inEnd     指向中序的终点
            if preStart > preEnd or inStart > inEnd:
                return None

            root_val = preorder[preStart]
            root_in_idx = inorderIdx[root_val]
            left_size = root_in_idx - inStart

            node = TreeNode(root_val)
            node.left = dfs(preStart+1, preStart+left_size, inStart, root_in_idx-1)
            node.right = dfs(preStart+left_size+1, preEnd, root_in_idx+1, inEnd)
            # 左子树：前序起点+1            前序起点+左子树宽度 中序起点    节点中序-1
            # 右子树：前序起点+左子树宽度+1 前序终点            节点中序+1  中序终点
            # 辅助记忆
            # 前序：节点 + 前序起点+1 -> 前序起点+左子树宽度 -> 前序起点+左子树宽度+1 -> 前序终点
            # 中序：中序起点 -> 节点中序-1 + 节点 + 节点中序+1 -> 中序终点
            
            return node

        return dfs(0, len(preorder) - 1, 0, len(inorder) - 1)
```

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

与上题同理

```python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:

        node_in_idx = collections.defaultdict(int)
        for i, v in enumerate(inorder):
            node_in_idx[v] = i

        def dfs(postStart, postEnd, inStart, inEnd):
            if postStart > postEnd or inStart > inEnd:
                return None
            
            node_val = postorder[postEnd]
            node_idx = node_in_idx[node_val]
            left_size = node_idx - inStart

            node = TreeNode(node_val)
            node.left = dfs(postStart, postStart+left_size-1, inStart, node_idx-1)
            node.right = dfs(postStart+left_size, postEnd-1, node_idx+1, inEnd)
            return node
        
        return dfs(0, len(postorder)-1, 0, len(inorder)-1)
```

#### [449. 序列化和反序列化二叉搜索树](https://leetcode-cn.com/problems/serialize-and-deserialize-bst/)

方法一：此题中元素的值是有重复的，但是它是个搜索树，所以也可以用 inOrderIdx 记录节点的index（此想法不一定对）

方法二：或者**在序列化时候，将没有的节点用 None 来记录**，就可以用同样的排序（只用一个前序）恢复为树，还可以有效避免元素的值重复，强烈建议用方法二

题解：https://leetcode-cn.com/problems/serialize-and-deserialize-bst/solution/xu-lie-hua-he-fan-xu-lie-hua-er-cha-sou-0fq67/

```python
# 方法一 76 ms 19.7 MB
class Codec:

    def serialize(self, root: TreeNode) -> str:
        """Encodes a tree to a single string.
        """
        # https://oi-wiki.org/ds/bst/
        # 搜索二叉树的中序排列时从小到大的
        # 返回前序排列，解码时将前序排列排个序，就是中序排列
        def dfs(node):
            if not node:
                return
            preOrder.append(node.val)
            dfs(node.left)
            dfs(node.right)

        preOrder = []
        dfs(root)
        return ",".join(map(str, preOrder))
        
    def deserialize(self, data: str) -> TreeNode:
        """Decodes your encoded data to tree.
        """
        # 从前序排列，根据二叉搜索树特性得出中序排列
        if data == "":
            return None
        preOrder = [int(x) for x in data.split(",")]
        inOrder = sorted(preOrder)
        
        # 如果节点的数值有重复的，就不能用下面的方法记录位置了，而是在每次遍历的过程中找
        inOrderIdx = collections.defaultdict(int)
        for i, v in enumerate(inOrder):
            inOrderIdx[v] = i

        def dfs(preStart, preEnd, inStart, inEnd):
            if preStart > preEnd or inStart > inEnd:
                return None
            
            node_val = preOrder[preStart]
            # node_in_idx = inStart
            # while inOrder[node_in_idx] != node_val:
            #     node_in_idx += 1
            node_in_idx = inOrderIdx[node_val]

            left_size = node_in_idx - inStart

            node = TreeNode(node_val)
            node.left = dfs(preStart+1, preStart+left_size, inStart, node_in_idx-1)
            node.right = dfs(preStart+left_size+1, preEnd, node_in_idx+1, inEnd)
            return node

        return dfs(0, len(preOrder)-1, 0, len(inOrder)-1)
```

```python
# 方法二 72 ms 19.6 MB
class Codec:

    def serialize(self, root: TreeNode) -> str:
        """Encodes a tree to a single string.
        """
        def dfs(node):
            if not node:
                preOrder.append("None")
                return
            preOrder.append(str(node.val))
            dfs(node.left)
            dfs(node.right)
        
        preOrder = []
        dfs(root)
        return ",".join(preOrder)
        

    def deserialize(self, data: str) -> TreeNode:
        """Decodes your encoded data to tree.
        """
        if data == "":
            return None
        # 强烈建议，这里不要用 [] (580 ms 19.9 MB),要用 collections.deque (72 ms 19.6 MB)
        preOrder = collections.deque([i for i in data.split(",")])
        def dfs(preOrder):
            node_val = preOrder.popleft()
            if node_val == "None":
                return None
            node = TreeNode(int(node_val))
            node.left = dfs(preOrder)
            node.right = dfs(preOrder)
            return node
        return dfs(preOrder)
```

#### [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

dfs 用同样的方法攻破 104 ms 19.6 MB 时间复杂度为 O(n) 空间复杂度为 O(n)

```python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        def dfs(node):
            if not node:
                inOrder.append("None")
                return 
            inOrder.append(str(node.val))
            dfs(node.left)
            dfs(node.right)

        inOrder = collections.deque()
        dfs(root)
        return ",".join(inOrder)

    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        if data == "":
            return None
        
        def dfs():
            node_val = inOrder.popleft()
            if node_val == "None":
                return
            node = TreeNode(node_val)
            node.left = dfs()
            node.right = dfs()
            return node

        inOrder = collections.deque([i for i in data.split(",")])
        return dfs()
```

bfs: 100 ms 19.7 MB 时间复杂度为 O(n) 空间复杂度为 O(n)

```python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return ""
        layerOrder = []
        queue = collections.deque()
        queue.append(root)

        while queue:
            node = queue.popleft()
            if node:
                queue.append(node.left)
                queue.append(node.right)
                layerOrder.append(str(node.val))
            else:
                layerOrder.append("None")
        print(",".join(layerOrder))
        return ",".join(layerOrder)
        
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        if data == "":
            return None
            
        layerOrder = [i for i in data.split(",")]
        queue = collections.deque()

        root = TreeNode(layerOrder[0])
        queue.append(root)
        idx = 1
        while queue:
            node = queue.popleft()
            if layerOrder[idx] != "None":
                node.left = TreeNode(int(layerOrder[idx]))
                queue.append(node.left)
            idx += 1
            if layerOrder[idx] != "None":
                node.right = TreeNode(int(layerOrder[idx]))
                queue.append(node.right)
            idx += 1
        return root
```
