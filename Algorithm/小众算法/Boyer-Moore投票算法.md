# Boyer-Moore 投票算法

## 前提

给定一个大小为 n 的数组，一定有个多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

## 思路

如果我们把众数记为 +1，把其他数记为 −1，将它们全部加起来，显然和大于 `0`，从结果本身我们可以看出众数比其他数多。

有点类似配对，即对于一群人，我们希望知道男的多还是女的多，我们不需要知道多少名男多少名女，而是让一男一女配对，成对的男女离场，看最后场中剩下的是男还是女。 

该问题可以理解为数组nums中相同的元素组成各自的队伍，maj所在的队伍人数最多，每个队伍都只支持自己所在的队伍，反对其他所有的队伍。

当赞成和反对某个队伍的人数相同时，我们可以让这些赞成者和反对者组合离场，然后随机选取一个队伍在进行这样的配对和离场。 

重点就是这道题中maj所在的队伍人数是大于总人数的一半的，不管怎样配对maj最后一定会被剩下，所以每次随机选取队伍进行“赞成该队伍”和“反对该队伍”的配对清场，不会影响maj队伍人数上的霸权地位。

## 算法

- 维护一个候选众数 candidate 和它出现的次数 vote。初始时 candidate 可以为任意值，vote 为 0；

- 我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：

  - 如果 x 与 candidate 相等，那么计数器 count 的值增加 1；

  - 如果 x 与 candidate 不等，那么计数器 count 的值减少 1。

在遍历完成后，candidate 即为整个数组的众数。

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int candidate = 0;
        int vote = 0;
        for (int num : nums) {
            if (vote == 0) {
                candidate = num;
            }
            vote += (num == candidate) ? 1 : -1;
        }
        return candidate;
    }
};
```
