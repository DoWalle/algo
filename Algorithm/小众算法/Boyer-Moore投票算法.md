# Boyer-Moore 投票算法

**摩尔投票法：摩尔投票法的核心思想为对拼消耗**

考虑最基本的摩尔投票问题：给定一个大小为 n 的数组，假定数组中一定有一个多数元素。多数元素是指在数组中「出现次数大于 n/2」的元素。

**优势：可以将空间复杂度从 `O(n)` 降至 `O(1)`**

## 思路

如果我们把众数记为 +1，把其他数记为 −1，将它们全部加起来，显然和大于 `0`，从结果本身我们可以看出众数比其他数多。

有点类似配对，即对于一群人，我们希望知道男的多还是女的多，我们不需要知道多少名男多少名女，而是让一男一女配对，成对的男女离场，看最后场中剩下的是男还是女。 

该问题可以理解为数组nums中相同的元素组成各自的队伍，maj所在的队伍人数最多，每个队伍都只支持自己所在的队伍，反对其他所有的队伍。

当赞成和反对某个队伍的人数相同时，我们可以让这些赞成者和反对者组合离场，然后随机选取一个队伍在进行这样的配对和离场。 

重点就是这道题中maj所在的队伍人数是大于总人数的一半的，不管怎样配对maj最后一定会被剩下，所以每次随机选取队伍进行“赞成该队伍”和“反对该队伍”的配对清场，不会影响maj队伍人数上的霸权地位。

## 算法

- 维护一个候选众数 candidate 和它出现的次数 vote。初始时 candidate 可以为任意值，vote 为 0；

- 我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：

  - 如果 x 与 candidate 相等，那么计数器 count 的值增加 1；

  - 如果 x 与 candidate 不等，那么计数器 count 的值减少 1。

在遍历完成后，candidate 即为整个数组的众数。

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int candidate = 0;
        int vote = 0;
        for (int num : nums) {
            if (vote == 0) {
                candidate = num;
            }
            vote += (num == candidate) ? 1 : -1;
        }
        return candidate;
    }
};
```

## 推广到 n / k 的情况

https://leetcode-cn.com/problems/majority-element-ii/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-ws0rj/

https://leetcode-cn.com/problems/majority-element-ii/solution/qiu-zhong-shu-ii-by-leetcode-solution-y1rn/

有一个对摩尔投票法非常形象的比喻：多方混战。

首先要知道，在任何数组中，出现次数大于该数组长度1/3的值最多只有两个。

我们把这道题比作一场多方混战，战斗结果一定只有最多两个阵营幸存，其他阵营被歼灭。数组中的数字即代表某士兵所在的阵营。

我们维护两个潜在幸存阵营A和B。我们遍历数组，如果遇到了属于A或者属于B的士兵，则把士兵加入A或B队伍中，该队伍人数加一。继续遍历。

如果遇到了一个士兵既不属于A阵营，也不属于B阵营，这时有两种情况：

情况一：A阵营和B阵营都还有活着的士兵，那么进行一次厮杀，参与厮杀的三个士兵全部阵亡：A阵营的一个士兵阵亡，B阵营的一个士兵阵亡，这个不知道从哪个阵营来的士兵也阵亡。继续遍历。

情况二：A阵营或B阵营已经没有士兵了。没有士兵的阵营暂时从地球上消失了。那么把当前遍历到的新士兵算作新的潜在幸存阵营，这个新阵营只有他一个人。继续遍历。

大战结束，最后A和B阵营就是初始人数最多的阵营。判断一下A，B的人数是否超过所有人数的三分之一就行了。
