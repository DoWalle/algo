#### [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

时间复杂度：`O(n^3)`

空间复杂度：`O(1)`

执行用时：44 ms, 在所有 Python3 提交中击败了67.03%的用户

内存消耗：18.2 MB, 在所有 Python3 提交中击败了95.11%的用户

```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        rows = len(board)
        cols = len(board[0])

        # O(n^2)
        def bfs(row, col):
            queue = [(row, col)]
            visited = {(row, col)}
            while queue:
                r, c = queue.pop(0)
                board[r][c] = "B"
                for dr, dc in ((1,0), (0,1), (-1,0), (0,-1)):
                    nr = r + dr
                    nc = c + dc
                    if 0<=nr<rows and 0<=nc<cols and board[nr][nc]=="O" and (nr, nc) not in visited:
                        queue.append((nr, nc))
                        visited.add((nr, nc))

        # O(n^3) 从四周开始传染
        for r in range(rows):
            if board[r][0] == "O": bfs(r, 0)
            if board[r][cols-1] == "O": bfs(r, cols-1)
        for c in range(cols):
            if board[0][c] == "O": bfs(0, c)
            if board[rows-1][c] == "O": bfs(rows-1, c)

        # O(n^2) 把传染的改成O，没有传染的就是被围的区域
        for r in range(rows):
            for c in range(cols):
                if board[r][c] == "B":
                    board[r][c] = "O"
                elif board[r][c] == "O":
                    board[r][c] = "X"
```

执行用时：16 ms, 在所有 Go 提交中击败了96.09%的用户

内存消耗：6.4 MB, 在所有 Go 提交中击败了30.35%的用户

```go
func solve(board [][]byte) {
	// fmt.Println([]byte("X")) // 88
	// fmt.Println([]byte("O")) // 79
	// fmt.Println([]byte("B")) // 66

	direction := [4][2]int{[2]int{1, 0}, [2]int{0, 1}, [2]int{-1, 0}, [2]int{0, -1}}
	rows := len(board)
	cols := len(board[0])

	bfs := func(row int, col int) {
		queue := [][2]int{[2]int{row, col}}
		visited := map[[2]int]int{[2]int{row, col}: 0}
		for len(queue) > 0 {
			r := queue[0][0]
			c := queue[0][1]
            queue = queue[1:]
			board[r][c] = 66
			for _, d := range direction {
				nr := r + d[0]
				nc := c + d[1]
				if nr >= 0 && nr < rows && nc >= 0 && nc < cols {
					if board[nr][nc] == 79 {
						if _, ok := visited[[2]int{nr, nc}]; !ok {
							queue = append(queue, [2]int{nr, nc})
							visited[[2]int{nr, nc}] = 0
						}
					}
				}
			}
		}
	}

	// O(n^3) 从四周开始传染
	for r := 0; r < rows; r++ {
		if board[r][0] == 79 {
			bfs(r, 0)
		}
		if board[r][cols-1] == 79 {
			bfs(r, cols-1)
		}
	}
	for c := 0; c < cols; c++ {
		if board[0][c] == 79 {
			bfs(0, c)
		}
		if board[rows-1][c] == 79 {
			bfs(rows-1, c)
		}
	}

	// O(n^2) 把传染的改成O，没有传染的就是被围的区域
	for r := 0; r < rows; r++ {
		for c := 0; c < cols; c++ {
			if board[r][c] == 66 {
				board[r][c] = 79
			} else if board[r][c] == 79 {
				board[r][c] = 88
			}
		}
	}

}
```
