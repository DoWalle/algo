题目：[743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

题解：[【宫水三叶】涵盖所有的「存图方式」与「最短路算法（详尽注释）」 - 网络延迟时间 - 力扣（LeetCode）](https://leetcode.cn/problems/network-delay-time/solution/gong-shui-san-xie-yi-ti-wu-jie-wu-chong-oghpz/)

## 方法一：bfs（临接表）

执行用时：108 ms, 在所有 C++ 提交中击败了44.63%的用户

内存消耗：38.9 MB, 在所有 C++ 提交中击败了53.54%的用户

```c++
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        unordered_map<int, vector<pair<int, int>>> adj;
        for (vector<int> &t : times) {
            adj[t[0]].push_back({t[1], t[2]});
        }

        deque<pair<int, int>> que = {{k, 0}}; // 当前节点，到达该节点的时间
        vector<int> visited(n+1, -1); // 记录到达该节点的最短时间
        visited[k] = 0;

        while (!que.empty()) {
            auto [cur, time] = que.front();
            que.pop_front();
            for (auto &[next, c] : adj[cur]) {
                int next_time = time + c;
                // 仅当结点未到达或达到时间比记录时间更早才更新并入队
                if (visited[next] == -1 || next_time < visited[next]) {
                    que.push_back({next, next_time});
                    visited[next] = next_time;
                }
            }
        }
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            if (visited[i] == -1) return -1;
            ans = max(ans, visited[i]);
        }
        return ans;
    }
};
```

## 方法二：dfs（临接表）

简单递归的搜索一遍图，当然继续向下搜索的前提是遍历到某一结点的时间有所改善，不然没必要继续向下继续搜索了，不过其实 DFS 对于求最短路并不合适

执行用时：660 ms, 在所有 C++ 提交中击败了5.23%的用户

内存消耗：39 MB, 在所有 C++ 提交中击败了44.13%的用户

```c++
class Solution {
public:
    unordered_map<int, vector<pair<int, int>>> adj;  // 临接表
    vector<int> visited;                             // 记录到达该节点的最短时间

    // 两个参数表示：到达 node 需要的时间 time
    void dfs(int node, int time) {
        // 如果这个点之前来过，并且这次来的时间大于上次来的时间，就没必要在来了
        if (visited[node] != -1 && time >= visited[node]) {
            return;
        }
        visited[node] = time;
        for (auto &[next, cost] : adj[node]) {
            dfs(next, time + cost);
        }
    }

    int networkDelayTime(vector<vector<int>> &times, int n, int k) {
        for (vector<int> &t : times) {
            adj[t[0]].push_back({t[1], t[2]});
        }
        visited.resize(n + 1, -1);

        dfs(k, 0);

        int ans = 0;
        for (int i = 1; i <= n; i++) {
            if (visited[i] == -1) return -1;
            ans = max(ans, visited[i]);
        }
        return ans;
    }
};
```

## 方法三：Floyd（邻接矩阵）



## 方法四：朴素 Dijkstra（邻接矩阵）



## 方法五：堆优化 Dijkstra（邻接表）
