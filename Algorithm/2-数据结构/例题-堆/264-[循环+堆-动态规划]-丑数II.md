[264. 丑数 II](https://leetcode-cn.com/problems/ugly-number-ii/)

## 方法一：循环+堆 先存再排

根据丑数的定义，有如下结论：

- 1 是最小的丑数
- 对于任意一个丑数 x，其与任意的质因数2、3、5相乘，结果2x、3x、5x仍为丑数

通过每次循环

1. 当前最小值与2、3、5相乘，相乘的结果肯定会之后的一次遍历中作为最小值，都入堆
2. 获取「小根堆」的堆顶，记录为下一次的最小值，然后移除
3. 类似 12 这个元素，可由 4 乘 3 得到，也可由 6 乘 2 得到，所以要去重

**在第 n 次循环的时候，获取到的「小根堆」堆顶，就是第 n 小的丑树**

时间复杂度：`O(nlogn)`

空间复杂度：`O(n)`

**底层容器为 vector 会快很多，有没有大佬知道为啥？**

执行用时：48 ms, 在所有 C++ 提交中击败了34.47%的用户

内存消耗：10.4 MB, 在所有 C++ 提交中击败了31.37%的用户

若为 `priority_queue<long, deque<long>, greater<long>> smallQ;`

执行用时：468 ms, 在所有 C++ 提交中击败了5.64%的用户

内存消耗：14.5 MB, 在所有 C++ 提交中击败了28.09%的用户

```c++
class Solution {
public:
    int nthUglyNumber(int n) {
        long ans = 1;
        priority_queue<long, vector<long>, greater<long>> smallQ;
        for (int i = 1; i < n; i++) {
            smallQ.push(ans * 2);
            smallQ.push(ans * 3);
            smallQ.push(ans * 5);

            ans = smallQ.top();
            smallQ.pop();

            while (!smallQ.empty() && smallQ.top() == ans) {
                smallQ.pop();
            }
        }
        return ans;
    }
};
```

## 方法二：动态规划 先排再存

https://leetcode-cn.com/problems/ugly-number-ii/solution/bao-li-you-xian-dui-lie-xiao-ding-dui-dong-tai-gui/

暂时还看不懂

